name: Deploy Worker

on:
    workflow_dispatch:
        inputs:
            environment:
                description: 'Environment to deploy to'
                required: true
                type: choice
                options:
                    - dev
                    - preview
                    - prod
            branch:
                description: 'Branch being deployed (for display)'
                required: false
                type: string
            sha:
                description: 'Commit SHA to deploy'
                required: false
                type: string

env:
    AWS_REGION: us-west-2
    ECR_REPOSITORY: jolli-worker

jobs:
    deploy:
        permissions:
            contents: read
            id-token: write
        runs-on: ubuntu-24.04
        steps:
            - name: Checkout
              uses: actions/checkout@v5
              with:
                  lfs: true
                  ref: ${{ inputs.sha || github.sha }}

            - name: Setup Node.js
              uses: actions/setup-node@v5
              with:
                  node-version-file: .nvmrc

            - name: Display deployment info
              id: env
              run: |
                  echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
                  echo "sha=${{ inputs.sha || github.sha }}" >> $GITHUB_OUTPUT
                  echo "::notice::Deploying branch: ${{ inputs.branch || 'manual' }}"
                  echo "::notice::Environment: ${{ inputs.environment }}"
                  echo "::notice::Commit: ${{ inputs.sha || github.sha }}"

            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-region: ${{ env.AWS_REGION }}
                  role-session-name: jolli-worker-deploy
                  role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}

            - name: Login to Amazon ECR
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Install dependencies
              run: npm ci

            - name: Check for infrastructure changes
              id: cdk-diff
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  cd deploy/worker-cdk
                  npm ci

                  # Check MemoryDB stack for changes
                  if npx cdk diff JolliMemoryDbStack-$ENVIRONMENT --fail 2>&1; then
                    echo "memorydb_changes=false" >> $GITHUB_OUTPUT
                    echo "::notice::No MemoryDB infrastructure changes detected"
                  else
                    echo "memorydb_changes=true" >> $GITHUB_OUTPUT
                    echo "::notice::MemoryDB infrastructure changes detected, will deploy"
                  fi

                  # Check Worker stack for changes
                  if npx cdk diff JolliWorkerStack-$ENVIRONMENT --fail 2>&1; then
                    echo "worker_changes=false" >> $GITHUB_OUTPUT
                    echo "::notice::No Worker infrastructure changes detected"
                  else
                    echo "worker_changes=true" >> $GITHUB_OUTPUT
                    echo "::notice::Worker infrastructure changes detected, will deploy"
                  fi

            - name: Deploy MemoryDB CDK infrastructure
              if: steps.cdk-diff.outputs.memorydb_changes == 'true'
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  cd deploy/worker-cdk
                  npx cdk deploy JolliMemoryDbStack-$ENVIRONMENT --require-approval never

            - name: Deploy Worker CDK infrastructure
              if: steps.cdk-diff.outputs.worker_changes == 'true'
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  cd deploy/worker-cdk
                  npx cdk deploy JolliWorkerStack-$ENVIRONMENT --require-approval never

            - name: Build worker bundle
              run: npm run worker:build --workspace=jolli-backend

            - name: Build and push Docker image
              env:
                  ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                  # Prefix SHA with "sha-" so ECR lifecycle rules can distinguish
                  # commit-tagged images from environment tags (dev, preview, prod)
                  IMAGE_TAG: sha-${{ steps.env.outputs.sha }}
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  # Build the Docker image
                  docker build \
                    -f backend/Dockerfile.worker \
                    -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                    -t $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT \
                    -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                    .

                  # Push all tags
                  docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
                  docker push $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT
                  docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

            - name: Deploy to ECS
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  # Force new deployment of the ECS service
                  aws ecs update-service \
                    --cluster jolli-workers-$ENVIRONMENT \
                    --service jolli-worker-$ENVIRONMENT \
                    --force-new-deployment \
                    --region $AWS_REGION

            - name: Wait for deployment
              id: wait-deployment
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  echo "Waiting for ECS service to stabilize..."
                  CLUSTER="jolli-workers-$ENVIRONMENT"
                  SERVICE="jolli-worker-$ENVIRONMENT"
                  MAX_ATTEMPTS=60  # 60 × 15s = 15 minutes
                  ATTEMPT=0

                  while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                    ATTEMPT=$((ATTEMPT + 1))

                    # Get deployment info
                    DEPLOYMENTS=$(aws ecs describe-services \
                      --cluster "$CLUSTER" \
                      --services "$SERVICE" \
                      --region "$AWS_REGION" \
                      --query 'services[0].deployments' \
                      --output json)

                    PRIMARY_STATUS=$(echo "$DEPLOYMENTS" | jq -r '.[0].rolloutState // "UNKNOWN"')
                    PRIMARY_RUNNING=$(echo "$DEPLOYMENTS" | jq -r '.[0].runningCount // 0')
                    PRIMARY_DESIRED=$(echo "$DEPLOYMENTS" | jq -r '.[0].desiredCount // 0')
                    DEPLOYMENT_COUNT=$(echo "$DEPLOYMENTS" | jq 'length')

                    echo "[$ATTEMPT/$MAX_ATTEMPTS] Status: $PRIMARY_STATUS | Running: $PRIMARY_RUNNING/$PRIMARY_DESIRED | Deployments: $DEPLOYMENT_COUNT"

                    # Success: single deployment that has completed rollout
                    if [ "$PRIMARY_STATUS" = "COMPLETED" ] && [ "$DEPLOYMENT_COUNT" -eq 1 ]; then
                      echo "Deployment complete!"
                      exit 0
                    fi

                    # Fail fast: circuit breaker triggered a rollback
                    if [ "$PRIMARY_STATUS" = "FAILED" ]; then
                      echo "::error::Deployment failed — ECS rollout state is FAILED"
                      aws ecs describe-services \
                        --cluster "$CLUSTER" \
                        --services "$SERVICE" \
                        --region "$AWS_REGION" \
                        --query 'services[0].deployments' \
                        --output table
                      exit 1
                    fi

                    sleep 15
                  done

                  echo "::error::Deployment failed to stabilize within 15 minutes"
                  aws ecs describe-services \
                    --cluster "$CLUSTER" \
                    --services "$SERVICE" \
                    --region "$AWS_REGION" \
                    --query 'services[0].deployments' \
                    --output table
                  exit 1

            - name: Rollback on failure
              if: failure() && steps.wait-deployment.outcome == 'failure'
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.environment }}
              run: |
                  echo "::warning::Deployment failed, ECS circuit breaker will handle rollback automatically"
                  # The ECS service has circuit breaker enabled with rollback: true
                  # so it will automatically rollback to the previous stable deployment
                  echo "Current deployments:"
                  aws ecs describe-services \
                    --cluster jolli-workers-$ENVIRONMENT \
                    --services jolli-worker-$ENVIRONMENT \
                    --region $AWS_REGION \
                    --query 'services[0].{desiredCount:desiredCount,runningCount:runningCount,deployments:deployments[*].{status:status,desiredCount:desiredCount,runningCount:runningCount,rolloutState:rolloutState}}' \
                    --output yaml
