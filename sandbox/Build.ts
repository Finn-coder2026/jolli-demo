import { execSync } from "node:child_process";
import { existsSync, unlinkSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { config as dotenvConfig } from "dotenv";

// Load .env / .env.local from the sandbox directory
dotenvConfig({ path: resolve(import.meta.dirname, ".env") });
dotenvConfig({ path: resolve(import.meta.dirname, ".env.local"), override: true });

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Reads a required environment variable or exits with an error. */
function requireEnv(name: string): string {
	const value = process.env[name];
	if (!value) {
		console.error(`Missing ${name}. Set it in your environment or in sandbox/.env.local`);
		process.exit(1);
	}
	return value;
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** Legacy template ID from the original e2b.toml / Dockerfile-based build */
export const LEGACY_TEMPLATE_ID = requireEnv("E2B_LEGACY_TEMPLATE_ID");

/** E2B team ID */
const TEAM_ID = requireEnv("E2B_TEAM_ID");

// ---------------------------------------------------------------------------
// Template registry
// ---------------------------------------------------------------------------

interface TemplateDef {
	/** Dockerfile path relative to sandbox/ */
	dockerfile: string;
	/** E2B template ID (from a previous `e2b template init` or build) */
	templateId: string;
}

/**
 * Each entry maps an alias to its Dockerfile and E2B template ID.
 *
 * The build shells out to `e2b template build` which sends the full
 * directory as build context (just like `docker build`), so COPY
 * directives in the Dockerfile work correctly.
 *
 * To add a new template:
 *   1. Create a Dockerfile
 *   2. Run `e2b template init` to get a template_id
 *   3. Add an entry here
 */
const TEMPLATE_DEFS: Record<string, TemplateDef> = {
	"e2b-legacy": {
		dockerfile: "e2b.Dockerfile",
		templateId: LEGACY_TEMPLATE_ID,
	},
};

export type TemplateName = keyof typeof TEMPLATE_DEFS;

// ---------------------------------------------------------------------------
// Build helpers
// ---------------------------------------------------------------------------

/**
 * Resolves the E2B API key from the environment.
 * Checks E2B_API_KEY env var (auto-loaded from .env / .env.local).
 */
function getApiKey(): string {
	return requireEnv("E2B_API_KEY");
}

/**
 * Validates that prepare scripts have staged required build artifacts.
 */
function assertPreparedArtifacts(): void {
	const requiredPaths = [
		resolve(import.meta.dirname, "dist"),
		resolve(import.meta.dirname, "dist/bin/jolli"),
	];

	for (const path of requiredPaths) {
		if (!existsSync(path)) {
			console.error(`Missing build artifact: ${path}`);
			console.error("Run `npm run prepare` in sandbox/ before building templates.");
			process.exit(1);
		}
	}
}

/**
 * Builds an E2B template by writing a temporary e2b.toml and shelling
 * out to `e2b template build`. The CLI sends full build context
 * (like `docker build`), so COPY directives work.
 */
function buildTemplate(alias: string, def: TemplateDef): void {
	console.log(`\n➡ Building template "${alias}" from ${def.dockerfile}`);

	const tomlPath = resolve(import.meta.dirname, "e2b.toml");
	const tomlContent = [
		`# Auto-generated by Build.ts — do not commit`,
		`team_id = "${TEAM_ID}"`,
		`dockerfile = "${def.dockerfile}"`,
		`template_id = "${def.templateId}"`,
	].join("\n");

	writeFileSync(tomlPath, tomlContent);

	try {
		execSync("e2b template build", {
			cwd: import.meta.dirname,
			stdio: "inherit",
		});
		console.log(`✓ Built "${alias}"`);
	} finally {
		// Clean up temporary toml
		try {
			unlinkSync(tomlPath);
		} catch {
			// Ignore cleanup errors
		}
	}
}

// ---------------------------------------------------------------------------
// CLI
// ---------------------------------------------------------------------------

function printUsage() {
	console.log(`
Usage: tsx Build.ts [template-name]

Templates:
${Object.entries(TEMPLATE_DEFS)
	.map(([alias, def]) => `  ${alias.padEnd(20)} → ${def.dockerfile} (${def.templateId})`)
	.join("\n")}

Examples:
  tsx Build.ts                 # build all templates
  tsx Build.ts e2b-legacy      # build only e2b-legacy

Constants:
  LEGACY_TEMPLATE_ID = ${LEGACY_TEMPLATE_ID}
  TEAM_ID            = ${TEAM_ID}

Local docker test:
  npm run docker:build
`);
}

function main() {
	const args = process.argv.slice(2);

	if (args.includes("--help") || args.includes("-h")) {
		printUsage();
		process.exit(0);
	}

	const target = args.find(a => !a.startsWith("-"));

	// Validate target if provided
	if (target && !(target in TEMPLATE_DEFS)) {
		console.error(`Unknown template: "${target}"\n`);
		console.error(`Available templates: ${Object.keys(TEMPLATE_DEFS).join(", ")}`);
		process.exit(1);
	}

	const entries = target ? [[target, TEMPLATE_DEFS[target]] as const] : Object.entries(TEMPLATE_DEFS);

	// Validate API key before starting builds
	getApiKey();
	assertPreparedArtifacts();

	console.log(`Building ${entries.length} template(s)...`);

	for (const [alias, def] of entries) {
		buildTemplate(alias, def);
	}

	console.log("\nDone.");
}

main();
