import {
	generateApiDocsHtml,
	generateApiDocsPage,
	generateApiReferenceComponent,
	generateCatchAllPage,
	generateContentMeta,
	generateFaviconRoute,
	generateIconComponent,
	generateLayout,
	generateMdxComponents,
	generateNextConfig,
	generateNoArticlesPage,
	generateRootRedirectPage,
	generateTsConfig,
	type MenuItemWithHref,
	type MenuNavMeta,
	type NavMeta,
} from "../templates/app-router/index.js";
import { generateAuthLayout, generateAuthLib } from "../templates/auth.js";
import { generateJwtAuthCallback, generateJwtAuthLib, generateJwtMiddleware } from "../templates/JwtAuth.js";
import type {
	ApiPageMeta,
	ArticleInput,
	ArticleMetadata,
	FileTree,
	GenerateToMemoryOptions,
	OpenApiSpecInfo,
	RedirectMapping,
	ThemeConfig,
} from "../types.js";
import {
	generateArticleContent,
	generateNavMeta,
	getEffectiveContentType,
	parseOpenApiSpec,
	slugifyWithRedirect,
} from "../utils/content.js";
import { MetaMerger } from "../utils/MetaMerger.js"; // new added
import { type ExistingNavMeta, isApiPageEntry, isExternalLink, isVirtualGroup } from "../utils/migration.js";
import type { FolderMetaInfo } from "jolli-common";

/**
 * Builds the theme configuration for in-memory generation.
 * Merges user-provided theme options with defaults.
 * Only includes properties that have defined values to satisfy exactOptionalPropertyTypes.
 */
function buildThemeConfig(displayName: string, siteName: string, userTheme?: Partial<ThemeConfig>): ThemeConfig {
	const config: ThemeConfig = {
		logo: userTheme?.logo ?? displayName,
		docsRepositoryBase: userTheme?.docsRepositoryBase ?? `https://github.com/Jolli-sample-repos/${siteName}`,
	};

	// Only add optional properties if they have defined values
	if (userTheme?.logoUrl !== undefined) {
		config.logoUrl = userTheme.logoUrl;
	}
	if (userTheme?.favicon !== undefined) {
		config.favicon = userTheme.favicon;
	}
	if (userTheme?.primaryHue !== undefined) {
		config.primaryHue = userTheme.primaryHue;
	}
	if (userTheme?.footer !== undefined) {
		config.footer = userTheme.footer;
	}
	if (userTheme?.defaultTheme !== undefined) {
		config.defaultTheme = userTheme.defaultTheme;
	}
	if (userTheme?.projectLink !== undefined) {
		config.projectLink = userTheme.projectLink;
	}
	if (userTheme?.chatLink !== undefined) {
		config.chatLink = userTheme.chatLink;
	}
	if (userTheme?.chatIcon !== undefined) {
		config.chatIcon = userTheme.chatIcon;
	}
	if (userTheme?.hideToc !== undefined) {
		config.hideToc = userTheme.hideToc;
	}
	if (userTheme?.tocTitle !== undefined) {
		config.tocTitle = userTheme.tocTitle;
	}
	if (userTheme?.sidebarDefaultCollapseLevel !== undefined) {
		config.sidebarDefaultCollapseLevel = userTheme.sidebarDefaultCollapseLevel;
	}

	return config;
}

/**
 * Builds a map from article slug to folder path from existing folder metadata.
 * Used to preserve article locations during site rebuild.
 *
 * @param allFolderMetas - Array of folder metadata with slugs in each folder
 * @returns Map from slug to folder path (empty string for root content folder)
 */
function buildSlugToFolderMap(allFolderMetas?: Array<FolderMetaInfo>): Map<string, string> {
	const map = new Map<string, string>();
	if (!allFolderMetas) {
		return map;
	}

	for (const folder of allFolderMetas) {
		for (const slug of folder.slugs) {
			map.set(slug, folder.folderPath);
		}
	}
	return map;
}

/**
 * Generates custom package.json with Jolli branding and optional auth (Nextra 4.x).
 * Includes pagefind for search functionality.
 * Note: The build script chains pagefind directly to ensure it runs on all platforms
 * (Vercel runs `next build` directly which skips npm postbuild hooks).
 */
function generateJolliPackageJson(siteName: string, allowedDomain?: string): string {
	const pkg: Record<string, unknown> = {
		name: siteName,
		version: "1.0.0",
		description: "Documentation generated by Jolli",
		type: "module",
		scripts: {
			dev: "next dev",
			build: "next build && pagefind --site .next/server/app --output-path public/_pagefind",
			start: "next start",
		},
		keywords: ["documentation", "nextra"],
		author: "Jolli",
		license: "MIT",
		dependencies: {
			next: "^15.0.0",
			nextra: "^4.0.0-app-router.12",
			"nextra-theme-docs": "^4.0.0-app-router.12",
			react: "^19.0.0",
			"react-dom": "^19.0.0",
		},
		devDependencies: {
			"@types/node": "^20.0.0",
			"@types/react": "^19.0.0",
			pagefind: "^1.3.0",
			typescript: "^5.0.0",
		},
	};

	// Add authentication dependencies if needed
	if (allowedDomain) {
		(pkg.dependencies as Record<string, string>)["@auth0/auth0-react"] = "^2.2.0";
	}

	// Always add JWT authentication dependencies (middleware checks env var at runtime)
	(pkg.dependencies as Record<string, string>).jose = "^5.2.0";

	return JSON.stringify(pkg, null, 2);
}

/**
 * Generates vercel.json for Vercel deployment configuration.
 * Uses `npm run build` to ensure pagefind runs after next build.
 */
function generateVercelJson(): string {
	const config = {
		buildCommand: "npm run build",
		outputDirectory: ".next",
		framework: "nextjs",
	};

	return JSON.stringify(config, null, 2);
}

/**
 * Generates .gitignore file for Nextra projects.
 */
function generateGitignore(): string {
	return `# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
build

# pagefind search index (generated at build time)
public/_pagefind/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
`;
}

/**
 * Extracts known folder paths from migration context.
 * Used to preserve folder entries during nav meta merge.
 */
function extractKnownFolders(allFolderMetas?: Array<FolderMetaInfo>): Array<string> {
	const knownFolders: Array<string> = [];
	if (allFolderMetas) {
		for (const folder of allFolderMetas) {
			if (folder.folderPath) {
				knownFolders.push(folder.folderPath);
			}
		}
	}
	return knownFolders;
}

/**
 * Builds merge options for MetaMerger from generation context.
 */
function buildMergeOptions(
	baseNavMeta: NavMeta,
	migrationContext: {
		existingNavMeta?: ExistingNavMeta;
		deletedSlugs?: Array<string>;
		allFolderMetas?: Array<FolderMetaInfo>;
	},
): Parameters<MetaMerger["mergeFromParsed"]>[0] {
	const newSlugs = Object.keys(baseNavMeta);
	const articleTitles = new Map<string, string>();
	for (const [slug, value] of Object.entries(baseNavMeta)) {
		if (typeof value === "string") {
			articleTitles.set(slug, value);
		}
	}

	const knownFolders = extractKnownFolders(migrationContext.allFolderMetas);

	// Build merge options, only including defined values (exactOptionalPropertyTypes)
	const mergeOptions: Parameters<MetaMerger["mergeFromParsed"]>[0] = {
		existingMeta: migrationContext.existingNavMeta as ExistingNavMeta,
		newArticleSlugs: newSlugs,
		articleTitles,
	};
	if (migrationContext.deletedSlugs !== undefined) {
		mergeOptions.deletedSlugs = migrationContext.deletedSlugs;
	}
	if (baseNavMeta !== undefined) {
		mergeOptions.baseNavMeta = baseNavMeta;
	}
	if (knownFolders.length > 0) {
		mergeOptions.knownFolders = knownFolders;
	}
	return mergeOptions;
}

/**
 * Converts MetaMerger result back to NavMeta format.
 * Handles API page entries, virtual groups, and complex entries.
 */
function convertMergeResultToNavMeta(
	mergeResult: ReturnType<MetaMerger["mergeFromParsed"]>,
	baseNavMeta: NavMeta,
): NavMeta {
	const finalNavMeta: NavMeta = {};
	if (!mergeResult.meta) {
		return finalNavMeta;
	}

	for (const [slug, entry] of Object.entries(mergeResult.meta)) {
		const baseEntry = baseNavMeta[slug];
		if (typeof entry === "string") {
			// Simple string entry - use API page entry from base if it exists
			if (typeof baseEntry === "object") {
				finalNavMeta[slug] = baseEntry;
			} else {
				finalNavMeta[slug] = entry;
			}
		} else if (isVirtualGroup(entry)) {
			// Virtual group - preserve it as-is (already filtered by MetaMerger)
			finalNavMeta[slug] = entry;
		} else if (isExternalLink(entry)) {
			// External link entries (e.g., { title: 'Contact', href: 'mailto:...' }) - always preserve
			finalNavMeta[slug] = entry;
		} else if (isApiPageEntry(entry)) {
			// API page entry - only preserve if it exists in the new generation
			// This filters out stale API entries when OpenAPI specs are removed
			if (baseNavMeta[slug] !== undefined) {
				finalNavMeta[slug] = entry;
			}
		} else {
			// Other complex entries (separator, etc.) - preserve as-is
			finalNavMeta[slug] = entry;
		}
	}

	return finalNavMeta;
}

/**
 * Type guard for MenuNavMeta (multiple API specs as menu dropdown)
 */
function isMenuNavMeta(entry: unknown): entry is MenuNavMeta {
	return (
		typeof entry === "object" &&
		entry !== null &&
		"type" in entry &&
		(entry as MenuNavMeta).type === "menu" &&
		"items" in entry
	);
}

/** Single→Single: preserve the custom title on the page entry */
function preservePageToPage(existing: ApiPageMeta, base: ApiPageMeta): ApiPageMeta {
	if (existing.title && existing.title !== "API Reference") {
		return { ...base, title: existing.title };
	}
	return base;
}

/** Single→Menu: move custom title to the specific item in the menu */
function preservePageToMenu(existing: ApiPageMeta, base: MenuNavMeta): MenuNavMeta {
	const existingSlug = existing.href?.replace("/api-docs/", "");
	if (existingSlug && existing.title && existing.title !== "API Reference") {
		const updatedItems: Record<string, MenuItemWithHref> = { ...base.items };
		if (updatedItems[existingSlug]) {
			updatedItems[existingSlug] = { ...updatedItems[existingSlug], title: existing.title };
		}
		return { ...base, items: updatedItems };
	}
	return base;
}

/** Menu→Menu: preserve individual item titles and parent menu title */
function preserveMenuToMenu(existing: MenuNavMeta, base: MenuNavMeta): MenuNavMeta {
	const updatedItems: Record<string, MenuItemWithHref> = { ...base.items };
	// Preserve custom titles for items that still exist
	for (const [itemSlug, itemEntry] of Object.entries(existing.items)) {
		if (updatedItems[itemSlug] && typeof itemEntry === "object" && "title" in itemEntry) {
			const existingTitle = (itemEntry as MenuItemWithHref).title;
			const baseItemTitle = updatedItems[itemSlug].title;
			if (existingTitle !== baseItemTitle) {
				updatedItems[itemSlug] = { ...updatedItems[itemSlug], title: existingTitle };
			}
		}
	}
	// Preserve custom parent menu title if set
	if (existing.title && existing.title !== "API Reference") {
		return { ...base, title: existing.title, items: updatedItems };
	}
	return { ...base, items: updatedItems };
}

/** Menu→Single: if remaining spec had custom title in items, apply to single page */
function preserveMenuToPage(existing: MenuNavMeta, base: ApiPageMeta): ApiPageMeta {
	const remainingSlug = base.href?.replace("/api-docs/", "");
	if (remainingSlug && existing.items[remainingSlug]) {
		const existingItem = existing.items[remainingSlug];
		if (typeof existingItem === "object" && "title" in existingItem) {
			return { ...base, title: (existingItem as MenuItemWithHref).title };
		}
	}
	return base;
}

/**
 * Preserves custom API Reference titles during regeneration.
 * Handles page↔menu transitions correctly by delegating to specialized helpers.
 */
function preserveApiReferenceTitles(
	existingApiRef: unknown,
	baseApiRef: ApiPageMeta | MenuNavMeta,
): ApiPageMeta | MenuNavMeta {
	if (isApiPageEntry(existingApiRef) && isApiPageEntry(baseApiRef)) {
		return preservePageToPage(existingApiRef, baseApiRef);
	}
	if (isApiPageEntry(existingApiRef) && isMenuNavMeta(baseApiRef)) {
		return preservePageToMenu(existingApiRef, baseApiRef);
	}
	if (isMenuNavMeta(existingApiRef) && isMenuNavMeta(baseApiRef)) {
		return preserveMenuToMenu(existingApiRef, baseApiRef);
	}
	if (isMenuNavMeta(existingApiRef) && isApiPageEntry(baseApiRef)) {
		return preserveMenuToPage(existingApiRef, baseApiRef);
	}
	return baseApiRef;
}

/**
 * Result of generating navigation meta with removed entry tracking
 */
interface GenerateNavigationMetaResult {
	navMeta: NavMeta;
	removedNavEntries: Array<string>;
}

/**
 * Gets the first article slug from the nav meta for the root redirect.
 * Skips API page entries (which have href), separators, and virtual groups.
 * Returns the first simple string entry (regular article).
 */
function getFirstArticleSlug(navMeta: NavMeta): string | null {
	for (const [slug, entry] of Object.entries(navMeta)) {
		// Simple string entry = regular article
		if (typeof entry === "string") {
			return slug;
		}
	}
	return null;
}

/**
 * Generates navigation meta, handling existing nav meta if present.
 * Merges existing nav meta with new articles to preserve user customizations.
 *
 * This is used in two scenarios:
 * 1. Migration mode: Upgrading from Nextra 3.x to 4.x, preserving old config
 * 2. Regeneration with navigation changes: Adding/removing articles while preserving
 *    user customizations to existing article titles in _meta.ts
 *
 * Supports nested virtual groups in existing nav meta - articles inside groups
 * are preserved if they match new articles.
 */
function generateNavigationMeta(
	articles: Array<ArticleInput>,
	openApiSpecs: Array<OpenApiSpecInfo>,
	migrationContext?: {
		existingNavMeta?: ExistingNavMeta;
		deletedSlugs?: Array<string>;
		allFolderMetas?: Array<FolderMetaInfo>;
	},
): GenerateNavigationMetaResult {
	const baseNavMeta = generateNavMeta(articles, openApiSpecs);

	// If we have existing nav meta, merge with it to preserve user customizations
	// This applies to both migration mode and regeneration with navigation changes
	if (!migrationContext?.existingNavMeta) {
		return { navMeta: baseNavMeta, removedNavEntries: [] };
	}

	// Merge: preserve existing titles/order/groups, add new articles, remove deleted/orphaned ones
	const merger = new MetaMerger();
	const mergeOptions = buildMergeOptions(baseNavMeta, migrationContext);
	const mergeResult = merger.mergeFromParsed(mergeOptions);

	// If merge failed, return base nav meta (MetaMerger handles errors gracefully)
	if (!mergeResult.success || !mergeResult.meta) {
		return { navMeta: baseNavMeta, removedNavEntries: [] };
	}

	// Convert back to NavMeta format (handle API page entries from baseNavMeta)
	const finalNavMeta = convertMergeResultToNavMeta(mergeResult, baseNavMeta);

	// Preserve custom API Reference titles from existing _meta.ts
	// Handles page↔menu transitions correctly via preserveApiReferenceTitles helper
	const existingApiRef = migrationContext.existingNavMeta["api-reference"];
	const baseApiRef = baseNavMeta["api-reference"];
	if (isApiPageEntry(baseApiRef)) {
		finalNavMeta["api-reference"] = preserveApiReferenceTitles(existingApiRef, baseApiRef);
	} else if (isMenuNavMeta(baseApiRef)) {
		finalNavMeta["api-reference"] = preserveApiReferenceTitles(existingApiRef, baseApiRef);
	}

	return { navMeta: finalNavMeta, removedNavEntries: mergeResult.report.removed };
}

/**
 * Processes an article and returns the file entries and potential redirect/OpenAPI info.
 */
interface ArticleProcessingContext {
	files: Array<FileTree>;
	redirects: Array<RedirectMapping>;
	openApiSpecs: Array<OpenApiSpecInfo>;
}

function processArticle(article: ArticleInput, slugToFolder: Map<string, string>, ctx: ArticleProcessingContext): void {
	const metadata = article.contentMetadata as ArticleMetadata | undefined;
	const title = metadata?.title || "Untitled Article";
	const slugResult = slugifyWithRedirect(title);
	const slug = slugResult.slug;

	// Track redirects for sanitized slugs (reserved words, leading digits, etc.)
	if (slugResult.needsRedirect) {
		ctx.redirects.push({
			source: `/${slugResult.originalSlug}`,
			destination: `/${slug}`,
			permanent: true,
		});
	}

	// Get effective content type (detects JSON/YAML even if contentType is wrong)
	const effectiveType = getEffectiveContentType(article.content, article.contentType);

	// Check if this is an OpenAPI spec
	if (parseOpenApiSpec(article.content, article.contentType) !== null) {
		// For OpenAPI specs, store in public folder with unique name based on slug
		const specExtension = effectiveType === "application/yaml" ? "yaml" : "json";
		const specFileName = `${slug}.${specExtension}`;

		ctx.files.push({ path: `public/${specFileName}`, content: article.content });
		ctx.openApiSpecs.push({ name: slug, specPath: `/${specFileName}`, title });
	} else if (effectiveType === "application/json" || effectiveType === "application/yaml") {
		// Non-OpenAPI JSON/YAML - save as raw file (not MDX to avoid parsing errors)
		const extension = effectiveType === "application/json" ? ".json" : ".yaml";
		const folderPath = slugToFolder.get(slug) || "";
		const basePath = folderPath ? `content/${folderPath}` : "content";
		ctx.files.push({ path: `${basePath}/${slug}${extension}`, content: article.content });
	} else {
		// Regular markdown content - goes in content/ folder
		const folderPath = slugToFolder.get(slug) || "";
		const basePath = folderPath ? `content/${folderPath}` : "content";
		ctx.files.push({ path: `${basePath}/${slug}.mdx`, content: generateArticleContent(article) });
	}
}

/**
 * Generates the root page file based on available articles and API specs.
 */
function generateRootPageFile(firstArticleSlug: string | null, openApiSpecs: Array<OpenApiSpecInfo>): FileTree {
	if (firstArticleSlug) {
		const rootPage = generateRootRedirectPage(firstArticleSlug);
		return { path: rootPage.path, content: rootPage.content };
	}
	if (openApiSpecs.length > 0) {
		const firstApiSlug = openApiSpecs[0].name;
		const rootPage = generateRootRedirectPage(`api-docs/${firstApiSlug}`);
		return { path: rootPage.path, content: rootPage.content };
	}
	const noArticlesPage = generateNoArticlesPage();
	return { path: noArticlesPage.path, content: noArticlesPage.content };
}

/**
 * Generates OpenAPI documentation files (HTML and React components).
 */
function generateOpenApiDocsFiles(openApiSpecs: Array<OpenApiSpecInfo>): Array<FileTree> {
	const files: Array<FileTree> = [];
	if (openApiSpecs.length === 0) {
		return files;
	}

	// Generate API docs page component
	const apiDocsSlugs = openApiSpecs.map(spec => spec.name);
	const apiDocsPage = generateApiDocsPage(apiDocsSlugs);
	files.push({ path: apiDocsPage.path, content: apiDocsPage.content });

	// Generate API reference client component
	const apiReference = generateApiReferenceComponent();
	files.push({ path: apiReference.path, content: apiReference.content });

	// Generate HTML files for each spec
	for (const spec of openApiSpecs) {
		const apiDocsHtmlFile = generateApiDocsHtml(spec.specPath);
		files.push({ path: `public/api-docs-${spec.name}.html`, content: apiDocsHtmlFile.content });
	}

	return files;
}

/**
 * Generates config files for the Nextra project (layout, catch-all, etc.).
 */
function generateProjectConfigFiles(
	themeConfig: ThemeConfig,
	siteName: string,
	allowedDomain: string | undefined,
	redirects: Array<RedirectMapping>,
): Array<FileTree> {
	const files: Array<FileTree> = [];

	// Generate app/layout.tsx - with or without auth
	if (allowedDomain) {
		const authLayout = generateAuthLayout(themeConfig, siteName, allowedDomain);
		const authLib = generateAuthLib(allowedDomain);
		files.push({ path: authLayout.path, content: authLayout.content });
		files.push({ path: authLib.path, content: authLib.content });
	} else {
		const layoutFile = generateLayout(themeConfig, siteName);
		files.push({ path: layoutFile.path, content: layoutFile.content });
	}

	// Always generate JWT auth files (middleware checks JWT_AUTH_ENABLED env var at runtime)
	const middleware = generateJwtMiddleware();
	const authCallback = generateJwtAuthCallback();
	const authLib = generateJwtAuthLib();
	files.push({ path: middleware.path, content: middleware.content });
	files.push({ path: authCallback.path, content: authCallback.content });
	files.push({ path: authLib.path, content: authLib.content });

	// Generate app/[...mdxPath]/page.tsx (catch-all route for MDX)
	const catchAllPage = generateCatchAllPage();
	files.push({ path: catchAllPage.path, content: catchAllPage.content });

	// Generate mdx-components.tsx (root level)
	const mdxComponents = generateMdxComponents();
	files.push({ path: mdxComponents.path, content: mdxComponents.content });

	// Generate app/icon.tsx for dynamic favicon
	const iconComponent = generateIconComponent();
	files.push({ path: iconComponent.path, content: iconComponent.content });

	// Generate app/favicon.ico/route.ts
	const faviconRoute = generateFaviconRoute();
	files.push({ path: faviconRoute.path, content: faviconRoute.content });

	// Generate next.config.mjs
	const nextConfig = generateNextConfig(redirects.length > 0 ? redirects : undefined);
	files.push({ path: nextConfig.path, content: nextConfig.content });

	// Generate tsconfig.json
	const tsConfig = generateTsConfig();
	files.push({ path: tsConfig.path, content: tsConfig.content });

	// Generate .gitignore
	files.push({ path: ".gitignore", content: generateGitignore() });

	return files;
}

/**
 * Result of generating a site to memory
 */
export interface GenerateSiteToMemoryResult {
	files: Array<FileTree>;
	removedNavEntries: Array<string>; // Navigation entries that were removed during merge
}

/**
 * Generates a complete Nextra 4.x project from a collection of articles.
 * Returns a FileTree array suitable for uploading to GitHub.
 *
 * This is the main function that the backend will call to generate sites.
 * Uses Nextra 4.x App Router structure:
 * - content/ folder for MDX files
 * - content/_meta.ts for navigation (TypeScript)
 * - app/layout.tsx for theme configuration
 * - app/[...mdxPath]/page.tsx for catch-all route
 *
 * @param articles - Array of article inputs (content, metadata, etc.)
 * @param options - Generation options (siteName, displayName, auth, regenerationMode, migrationMode)
 * @returns Object with files array and removedNavEntries for logging
 */
export function generateSiteToMemory(
	articles: Array<ArticleInput>,
	options: GenerateToMemoryOptions,
): GenerateSiteToMemoryResult {
	const { siteName, displayName, auth, regenerationMode = false, migrationMode = false, migrationContext } = options;
	const allowedDomain = auth?.allowedDomain;
	const skipConfigFiles = regenerationMode && !migrationMode;
	const slugToFolder = buildSlugToFolderMap(migrationContext?.allFolderMetas);

	// Process articles into files
	const ctx: ArticleProcessingContext = { files: [], redirects: [], openApiSpecs: [] };
	for (const article of articles) {
		processArticle(article, slugToFolder, ctx);
	}

	// Filter to only root-level articles for navigation
	const rootFolderArticles = articles.filter(article => {
		const metadata = article.contentMetadata as ArticleMetadata | undefined;
		const title = metadata?.title || "Untitled Article";
		const slug = slugifyWithRedirect(title).slug;
		return (slugToFolder.get(slug) || "") === "";
	});

	// Generate navigation meta
	const navMetaResult = generateNavigationMeta(rootFolderArticles, ctx.openApiSpecs, migrationContext);
	const metaFile = generateContentMeta(navMetaResult.navMeta);
	ctx.files.push({ path: metaFile.path, content: metaFile.content });

	// Generate OpenAPI docs files
	ctx.files.push(...generateOpenApiDocsFiles(ctx.openApiSpecs));

	// Build theme configuration
	const mergedTheme =
		migrationMode && migrationContext?.themeConfig
			? { ...migrationContext.themeConfig, ...options.theme }
			: options.theme;
	const themeConfig = buildThemeConfig(displayName, siteName, mergedTheme);

	// ALWAYS regenerate app/page.tsx since it contains the redirect to the first article.
	// If articles are added/removed/reordered, the redirect target may change.
	const firstArticleSlug = getFirstArticleSlug(navMetaResult.navMeta);
	ctx.files.push(generateRootPageFile(firstArticleSlug, ctx.openApiSpecs));

	// Generate other config files only on initial creation (not regeneration)
	if (!skipConfigFiles) {
		ctx.files.push(...generateProjectConfigFiles(themeConfig, siteName, allowedDomain, ctx.redirects));
	}

	// ALWAYS generate package.json and vercel.json (critical for build/deploy)
	ctx.files.push({ path: "package.json", content: generateJolliPackageJson(siteName, allowedDomain) });
	ctx.files.push({ path: "vercel.json", content: generateVercelJson() });

	return { files: ctx.files, removedNavEntries: navMetaResult.removedNavEntries };
}

/**
 * Returns file paths that need to be deleted when migrating from Nextra 3.x to 4.x.
 * These are the old Page Router files that are replaced by App Router structure.
 */
export function getNextra3xFilesToDelete(): Array<string> {
	return [
		// Page Router files (all possible extensions: .js, .jsx, .ts, .tsx)
		"pages/_app.js",
		"pages/_app.jsx",
		"pages/_app.ts",
		"pages/_app.tsx",
		"pages/_document.js",
		"pages/_document.jsx",
		"pages/_document.ts",
		"pages/_document.tsx",
		"pages/_error.js",
		"pages/_error.jsx",
		"pages/_error.ts",
		"pages/_error.tsx",
		"pages/404.js",
		"pages/404.jsx",
		"pages/404.ts",
		"pages/404.tsx",
		"pages/_meta.js",
		"pages/_meta.global.js",
		"pages/index.mdx",
		// Old auto-generated index page (now replaced by root redirect - JOLLI-191)
		"content/index.mdx",
		// Theme config (replaced by app/layout.tsx)
		"theme.config.js",
		"theme.config.jsx",
		"theme.config.ts",
		"theme.config.tsx",
		// Old Nextra 3.x OpenAPI components (not used in 4.x)
		"components/ViewContext.tsx",
		"components/NavbarApiButton.tsx",
		"components/LogoLink.tsx",
	];
}
