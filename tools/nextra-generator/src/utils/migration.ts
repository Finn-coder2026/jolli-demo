/**
 * Nextra 3.x to 4.x Migration Utilities
 *
 * Handles parsing Nextra 3.x config files and converting them to 4.x format.
 * Also supports merging existing _meta.js navigation with new articles.
 */

import type { ThemeConfig } from "../types.js";
import type {
	ApiPageMetaEntry,
	ExistingNavMeta,
	ExistingNavMetaEntry,
	FlatNavMeta,
	MenuItemWithHref,
	MenuNavMeta,
	SeparatorMeta,
	VirtualGroupMeta,
} from "jolli-common";

// Re-export types from jolli-common for consumers of nextra-generator
export type {
	ApiPageMetaEntry,
	ExistingNavMeta,
	ExistingNavMetaEntry,
	FlatNavMeta,
	MenuItemWithHref,
	MenuNavMeta,
	SeparatorMeta,
	VirtualGroupMeta,
};

/**
 * Extracted config from Nextra 3.x theme.config.jsx
 * Only includes properties that can be migrated to 4.x
 */
export interface Nextra3Config {
	logo?: string;
	projectLink?: string;
	docsRepositoryBase?: string;
	footer?: string;
	primaryHue?: number;
	defaultTheme?: "light" | "dark" | "system";
	tocTitle?: string;
	sidebarDefaultCollapseLevel?: number;
}

/**
 * Type guard to check if an entry is a virtual group
 */
export function isVirtualGroup(entry: ExistingNavMetaEntry): entry is VirtualGroupMeta {
	return typeof entry === "object" && "items" in entry && typeof entry.items === "object";
}

/**
 * Type guard to check if an entry is an API page (has type: 'page' AND href)
 */
export function isApiPageEntry(entry: unknown): entry is ApiPageMetaEntry {
	return (
		typeof entry === "object" &&
		entry !== null &&
		"type" in entry &&
		(entry as ApiPageMetaEntry).type === "page" &&
		"href" in entry &&
		typeof (entry as ApiPageMetaEntry).href === "string"
	);
}

/**
 * Type guard to check if an entry is an external link (has href but no type field).
 * Examples: { title: 'Contact', href: 'mailto:...' } or { href: 'https://...' }
 */
export function isExternalLink(entry: unknown): entry is { title?: string; href: string } {
	return (
		typeof entry === "object" &&
		entry !== null &&
		!("type" in entry) &&
		"href" in entry &&
		typeof (entry as { href: string }).href === "string"
	);
}

/**
 * Type guard to check if an entry is a separator
 */
export function isSeparator(entry: ExistingNavMetaEntry): entry is SeparatorMeta {
	return typeof entry === "object" && "type" in entry && entry.type === "separator";
}

/**
 * Result of parsing Nextra 3.x config files
 */
export interface MigrationParseResult {
	themeConfig: Nextra3Config;
	navMeta: ExistingNavMeta;
	warnings: Array<string>;
}

/**
 * Parses Nextra 3.x theme.config.jsx content and extracts migratable properties.
 * This is a best-effort parser that handles common patterns.
 *
 * @param content - The content of theme.config.jsx
 * @returns Extracted configuration that can be migrated to 4.x
 */
export function parseNextra3ThemeConfig(content: string): { config: Nextra3Config; warnings: Array<string> } {
	const config: Nextra3Config = {};
	const warnings: Array<string> = [];

	// Extract project link: project: { link: 'https://...' }
	const projectLinkMatch = content.match(/project:\s*\{\s*link:\s*['"]([^'"]+)['"]/);
	if (projectLinkMatch) {
		config.projectLink = projectLinkMatch[1];
	}

	// Extract docsRepositoryBase: docsRepositoryBase: 'https://...'
	const docsRepoMatch = content.match(/docsRepositoryBase:\s*['"]([^'"]+)['"]/);
	if (docsRepoMatch) {
		config.docsRepositoryBase = docsRepoMatch[1];
	}

	// Extract footer text: footer: { text: 'Footer Text' } or text: 'Footer · Powered by Jolli'
	const footerMatch = content.match(/footer:\s*\{\s*text:\s*['"]([^'"]+)['"]/);
	if (footerMatch) {
		// Remove "Powered/Generated by Jolli" suffix as it will be added by 4.x generator
		let footerText = footerMatch[1];
		footerText = footerText.replace(/\s*·?\s*(?:Generated|Powered) by Jolli\s*$/i, "").trim();
		if (footerText) {
			config.footer = footerText;
		}
	}

	// Extract primary hue from style: --nextra-primary-hue: 212deg
	const hueMatch = content.match(/--nextra-primary-hue:\s*(\d+)deg/);
	if (hueMatch) {
		config.primaryHue = Number.parseInt(hueMatch[1], 10);
	}

	// Extract default theme: defaultTheme: 'system'
	const themeMatch = content.match(/defaultTheme:\s*['"](\w+)['"]/);
	if (themeMatch) {
		const theme = themeMatch[1];
		if (theme === "light" || theme === "dark" || theme === "system") {
			config.defaultTheme = theme;
		}
	}

	// Extract toc title: toc: { title: 'On This Page' }
	const tocMatch = content.match(/toc:\s*\{\s*title:\s*['"]([^'"]+)['"]/);
	if (tocMatch) {
		config.tocTitle = tocMatch[1];
	}

	// Extract sidebar collapse level: sidebar: { defaultMenuCollapseLevel: 2 }
	const collapseMatch = content.match(/defaultMenuCollapseLevel:\s*(\d+)/);
	if (collapseMatch) {
		config.sidebarDefaultCollapseLevel = Number.parseInt(collapseMatch[1], 10);
	}

	// Check for unsupported features and add warnings
	if (content.includes("useNextSeoProps")) {
		warnings.push("useNextSeoProps is not supported in Nextra 4.x - SEO is handled via metadata export");
	}
	if (content.includes("navbar:") && content.includes("extraContent")) {
		warnings.push("navbar.extraContent is not directly supported - custom navbar components need manual migration");
	}
	if (content.includes("LogoLink") || content.includes("logo: <")) {
		warnings.push("Custom logo components (JSX) cannot be automatically migrated - using text logo instead");
	}

	return { config, warnings };
}

// ===== DEPRECATED: Replaced by MetaMerger class =====
// /**
//  * Parses Nextra 3.x _meta.js content and extracts navigation structure.
//  * Only handles flat structure with string values.
//  *
//  * @param content - The content of _meta.js (pages/_meta.js or pages/_meta.global.js)
//  * @returns Navigation meta entries (flat structure only)
//  * @deprecated Use parseNavMeta for Nextra 4.x content with nested structures
//  */
// export function parseNextra3NavMeta(content: string): ExistingNavMeta {
// 	const meta: ExistingNavMeta = {};
//
// 	// Match patterns like: "slug": "Title" or 'slug': 'Title'
// 	const entryPattern = /["']([^"']+)["']\s*:\s*["']([^"']+)["']/g;
// 	let match: RegExpExecArray | null = null;
//
// 	while (true) {
// 		match = entryPattern.exec(content);
// 		if (match === null) {
// 			break;
// 		}
// 		const [, key, value] = match;
// 		meta[key] = value;
// 	}
//
// 	return meta;
// }

// /**
//  * Parses _meta.ts content and extracts navigation structure.
//  * Handles both flat and nested structures (virtual groups, API pages, separators).
//  *
//  * Uses a safe evaluation approach by extracting the object from `export default { ... }`
//  * and using Function constructor (safer than eval, but still only use on trusted content).
//  *
//  * @param content - The content of _meta.ts
//  * @returns Navigation meta entries with full structure preserved
//  * @deprecated Use MetaMerger.validateSyntax() and MetaMerger.merge() instead
//  */
// export function parseNavMeta(content: string): ExistingNavMeta {
// 	try {
// 		// Extract the object from "export default { ... }" pattern
// 		// This handles both `export default {` and variations with comments
// 		const exportMatch = content.match(/export\s+default\s+(\{[\s\S]*\})\s*;?\s*$/);
// 		if (!exportMatch) {
// 			// Fallback to legacy parser if no export default found
// 			return parseNextra3NavMeta(content);
// 		}
//
// 		const objectLiteral = exportMatch[1];
//
// 		// Use Function constructor to safely evaluate the object literal
// 		// This is safer than eval() as it doesn't have access to local scope
// 		const parsed = new Function(`return (${objectLiteral})`)();
//
// 		// Validate and convert to ExistingNavMeta
// 		if (typeof parsed !== "object" || parsed === null) {
// 			return parseNextra3NavMeta(content);
// 		}
//
// 		return validateAndConvertNavMeta(parsed);
// 	} catch {
// 		// If parsing fails, fallback to legacy parser
// 		return parseNextra3NavMeta(content);
// 	}
// }

// /**
//  * Checks if an item value is a MenuItemWithHref (has title and href strings)
//  */
// function isMenuItemWithHref(value: unknown): value is MenuItemWithHref {
// 	return (
// 		typeof value === "object" &&
// 		value !== null &&
// 		"title" in value &&
// 		typeof (value as MenuItemWithHref).title === "string" &&
// 		"href" in value &&
// 		typeof (value as MenuItemWithHref).href === "string"
// 	);
// }
//
// /**
//  * Checks if all items in an object are MenuItemWithHref (for API Reference dropdown)
//  */
// function hasMenuItemsWithHref(items: Record<string, unknown>): boolean {
// 	const values = Object.values(items);
// 	return values.length > 0 && values.every(isMenuItemWithHref);
// }
//
// /**
//  * Converts a menu object to MenuNavMeta type (for API Reference dropdown with multiple specs)
//  */
// function convertToMenuNavMeta(key: string, obj: Record<string, unknown>): MenuNavMeta {
// 	const items: Record<string, MenuItemWithHref> = {};
// 	const rawItems = obj.items as Record<string, unknown>;
// 	for (const [itemKey, itemValue] of Object.entries(rawItems)) {
// 		if (isMenuItemWithHref(itemValue)) {
// 			items[itemKey] = { title: itemValue.title, href: itemValue.href };
// 		}
// 	}
// 	return {
// 		title: typeof obj.title === "string" ? obj.title : key,
// 		type: "menu",
// 		items,
// 	};
// }
//
// /**
//  * Converts a virtual group object to VirtualGroupMeta type.
//  */
// function convertToVirtualGroup(key: string, obj: Record<string, unknown>): VirtualGroupMeta {
// 	const items: Record<string, string> = {};
// 	const rawItems = obj.items as Record<string, unknown>;
// 	for (const [itemKey, itemValue] of Object.entries(rawItems)) {
// 		if (typeof itemValue === "string") {
// 			items[itemKey] = itemValue;
// 		}
// 	}
// 	return {
// 		title: typeof obj.title === "string" ? obj.title : key,
// 		type: obj.type === "menu" ? "menu" : "page",
// 		items,
// 	};
// }
//
// /**
//  * Converts an API page object to ApiPageMetaEntry type.
//  */
// function convertToApiPageEntry(key: string, obj: Record<string, unknown>): ApiPageMetaEntry {
// 	return {
// 		title: typeof obj.title === "string" ? obj.title : key,
// 		type: "page",
// 		href: obj.href as string,
// 	};
// }
//
// /**
//  * Converts a single parsed entry to the appropriate meta entry type.
//  */
// function convertNavMetaEntry(key: string, value: unknown): ExistingNavMetaEntry | undefined {
// 	if (typeof value === "string") {
// 		return value;
// 	}
//
// 	if (typeof value !== "object" || value === null) {
// 		return;
// 	}
//
// 	const obj = value as Record<string, unknown>;
//
// 	// Check for entries with items (could be MenuNavMeta or VirtualGroupMeta)
// 	if ("items" in obj && typeof obj.items === "object" && obj.items !== null) {
// 		const items = obj.items as Record<string, unknown>;
// 		// If items contain objects with href (MenuItemWithHref), it's a MenuNavMeta (API Reference dropdown)
// 		if (hasMenuItemsWithHref(items)) {
// 			return convertToMenuNavMeta(key, obj);
// 		}
// 		// Otherwise it's a VirtualGroupMeta (article grouping with string titles)
// 		return convertToVirtualGroup(key, obj);
// 	}
//
// 	// Check for API page (has href)
// 	if ("href" in obj && typeof obj.href === "string") {
// 		return convertToApiPageEntry(key, obj);
// 	}
//
// 	// Check for separator (may have optional title)
// 	if (obj.type === "separator") {
// 		const separator: SeparatorMeta = { type: "separator" };
// 		if (typeof obj.title === "string") {
// 			separator.title = obj.title;
// 		}
// 		return separator;
// 	}
//
// 	// Unknown entry type
// 	return;
// }
//
// /**
//  * Validates and converts a parsed object to ExistingNavMeta type.
//  * Ensures all entries conform to expected types.
//  */
// function validateAndConvertNavMeta(parsed: Record<string, unknown>): ExistingNavMeta {
// 	const result: ExistingNavMeta = {};
//
// 	for (const [key, value] of Object.entries(parsed)) {
// 		const converted = convertNavMetaEntry(key, value);
// 		if (converted !== undefined) {
// 			result[key] = converted;
// 		}
// 	}
//
// 	return result;
// }

/**
 * Converts Nextra 3.x config to Nextra 4.x ThemeConfig format.
 *
 * @param config - Parsed Nextra 3.x config
 * @param siteName - Site name for fallback values
 * @param displayName - Display name for logo
 * @returns ThemeConfig for Nextra 4.x
 */
export function convertToNextra4Config(config: Nextra3Config, siteName: string, displayName: string): ThemeConfig {
	const themeConfig: ThemeConfig = {
		logo: displayName,
		docsRepositoryBase: config.docsRepositoryBase ?? `https://github.com/Jolli-sample-repos/${siteName}`,
	};

	if (config.projectLink) {
		themeConfig.projectLink = config.projectLink;
	}

	if (config.footer) {
		themeConfig.footer = config.footer;
	}

	if (config.primaryHue !== undefined) {
		themeConfig.primaryHue = config.primaryHue;
	}

	if (config.defaultTheme) {
		themeConfig.defaultTheme = config.defaultTheme;
	}

	if (config.tocTitle) {
		themeConfig.tocTitle = config.tocTitle;
	}

	if (config.sidebarDefaultCollapseLevel !== undefined) {
		themeConfig.sidebarDefaultCollapseLevel = config.sidebarDefaultCollapseLevel;
	}

	return themeConfig;
}

// /**
//  * Result of merging navigation meta
//  * @deprecated Use MetaMergeResult from MetaMerger.ts instead
//  */
// export interface MergeNavMetaResult {
// 	meta: ExistingNavMeta;
// 	removedEntries: Array<string>; // Slugs that were in existing meta but removed
// }
//
// /**
//  * Merges existing navigation meta with new articles.
//  * Supports nested virtual groups - articles inside groups are preserved if they match new articles.
//  * Preserves user customizations (titles, order, groups) while adding new articles at top level.
//  * Only keeps entries that are in newArticleSlugs (removes deselected/orphaned entries).
//  *
//  * @param existingMeta - Navigation meta from existing _meta.ts (may contain virtual groups)
//  * @param newArticleSlugs - Array of new article slugs to add
//  * @param articleTitles - Map of slug to title for new articles
//  * @param deletedSlugs - Array of slugs that should be removed
//  * @returns Merged navigation meta with removed entries for logging
//  * @deprecated Use MetaMerger.merge() instead
//  */
// export function mergeNavMeta(
// 	existingMeta: ExistingNavMeta,
// 	newArticleSlugs: Array<string>,
// 	articleTitles: Map<string, string>,
// 	deletedSlugs: Array<string> = [],
// ): MergeNavMetaResult {
// 	const result: ExistingNavMeta = {};
// 	const deletedSet = new Set(deletedSlugs);
// 	const newSlugSet = new Set(newArticleSlugs);
// 	const removedEntries: Array<string> = [];
// 	const usedSlugs = new Set<string>(); // Track slugs found in existing meta
//
// 	// Step 1: Process existing entries, preserving structure but removing orphans
// 	for (const [key, value] of Object.entries(existingMeta)) {
// 		if (typeof value === "string") {
// 			// Simple entry - check if slug exists in new articles
// 			if (newSlugSet.has(key) && !deletedSet.has(key)) {
// 				result[key] = value;
// 				usedSlugs.add(key);
// 			} else if (key !== "index") {
// 				// Track removed entries (except "index" which is always regenerated)
// 				removedEntries.push(key);
// 			}
// 		} else if (isVirtualGroup(value)) {
// 			// Virtual group with items - filter items, keep group if any items remain
// 			const filteredItems: Record<string, string> = {};
// 			for (const [itemKey, itemValue] of Object.entries(value.items)) {
// 				if (newSlugSet.has(itemKey) && !deletedSet.has(itemKey)) {
// 					filteredItems[itemKey] = itemValue;
// 					usedSlugs.add(itemKey);
// 				} else {
// 					// Track nested removal with path notation
// 					removedEntries.push(`${key}/${itemKey}`);
// 				}
// 			}
//
// 			// Only keep group if it has remaining items
// 			if (Object.keys(filteredItems).length > 0) {
// 				result[key] = {
// 					...value,
// 					items: filteredItems,
// 				};
// 			} else {
// 				// Empty group - remove entirely
// 				removedEntries.push(`${key} (empty group)`);
// 			}
// 		} else if (isApiPageEntry(value)) {
// 			// API page entry - keep as-is (not article-based)
// 			result[key] = value;
// 		} else if (isSeparator(value)) {
// 			// Separator - keep as-is
// 			result[key] = value;
// 		}
// 	}
//
// 	// Step 2: Add new articles that weren't found in existing meta (at top level)
// 	for (const slug of newArticleSlugs) {
// 		if (!usedSlugs.has(slug) && !deletedSet.has(slug)) {
// 			result[slug] = articleTitles.get(slug) ?? slug;
// 		}
// 	}
//
// 	// Step 3: Ensure index is always first
// 	if ("index" in result) {
// 		const indexEntry = result.index;
// 		delete result.index;
// 		return { meta: { index: indexEntry, ...result }, removedEntries };
// 	}
//
// 	return { meta: result, removedEntries };
// }
// ===== END DEPRECATED =====

/**
 * Files that should be deleted when migrating from Nextra 3.x to 4.x
 */
export const NEXTRA_3X_FILES_TO_DELETE = [
	// Page Router files (all possible extensions: .js, .jsx, .ts, .tsx)
	"pages/_app.js",
	"pages/_app.jsx",
	"pages/_app.ts",
	"pages/_app.tsx",
	"pages/_document.js",
	"pages/_document.jsx",
	"pages/_document.ts",
	"pages/_document.tsx",
	"pages/_error.js",
	"pages/_error.jsx",
	"pages/_error.ts",
	"pages/_error.tsx",
	"pages/404.js",
	"pages/404.jsx",
	"pages/404.ts",
	"pages/404.tsx",
	"pages/_meta.js",
	"pages/_meta.global.js",
	"pages/index.mdx",
	// Theme config (replaced by app/layout.tsx)
	"theme.config.js",
	"theme.config.jsx",
	"theme.config.ts",
	"theme.config.tsx",
	// Old Nextra 3.x OpenAPI components (not used in 4.x)
	"components/ViewContext.tsx",
	"components/NavbarApiButton.tsx",
	"components/LogoLink.tsx",
];

/**
 * Directories that should be deleted when migrating from Nextra 3.x to 4.x
 * (only if they contain Page Router content)
 */
export const NEXTRA_3X_DIRS_TO_CHECK = [
	"pages", // Will be replaced by content/
];

/**
 * Checks if a file path is a Nextra 3.x specific file that should be deleted
 */
export function isNextra3xFile(path: string): boolean {
	return NEXTRA_3X_FILES_TO_DELETE.includes(path);
}

/**
 * Gets all MDX files from pages/ directory that need to be moved to content/
 */
export function getPagesMdxFiles(existingFiles: Array<{ path: string; content: string }>): Array<{
	oldPath: string;
	newPath: string;
	content: string;
}> {
	const mdxFiles: Array<{ oldPath: string; newPath: string; content: string }> = [];

	for (const file of existingFiles) {
		// Match pages/*.mdx but not pages/_*.mdx (meta files)
		if (file.path.startsWith("pages/") && file.path.endsWith(".mdx") && !file.path.includes("/_")) {
			const filename = file.path.replace("pages/", "");
			mdxFiles.push({
				oldPath: file.path,
				newPath: `content/${filename}`,
				content: file.content,
			});
		}
	}

	return mdxFiles;
}
