import * as templates from "../templates/app-router/index.js";
import type { GeneratorConfig, GeneratorResult, OpenApiSpecInfo, PageConfig, ThemeConfig } from "../types.js";
import { slugify } from "../utils/content.js";
import { resolvePath, writeFile } from "../utils/file.js";
import { buildFullNavigationMeta, buildNavigationMeta, processInputFiles } from "../utils/input-files.js";
import { loadOpenApiSpec } from "../utils/openapi.js";
import path from "node:path";

const DEFAULT_THEME: ThemeConfig = {
	logo: "My Documentation",
	// Other fields use defaults from generateLayout():
	// - footer defaults to "Generated by Jolli"
	// - projectLink defaults to Jolli-sample-repos/{siteName} if siteName provided
};

/**
 * Process OpenAPI JSON files and generate corresponding assets
 */
async function processOpenApiJsonFiles(
	jsonFiles: Array<{ targetPath: string; data: object; sourcePath: string }>,
	outputDir: string,
	filesCreated: Array<string>,
): Promise<Array<OpenApiSpecInfo>> {
	const openApiSpecs: Array<OpenApiSpecInfo> = [];

	for (const jsonFile of jsonFiles) {
		const jsonData = jsonFile.data as Record<string, unknown>;
		if (!("openapi" in jsonData || "swagger" in jsonData)) {
			continue;
		}

		const baseName = path.basename(jsonFile.targetPath);
		const specName = slugify(baseName);
		const specPath = `public/api-docs-${specName}.json`;
		const specDestPath = resolvePath(outputDir, specPath);
		await writeFile(specDestPath, JSON.stringify(jsonData, null, 2));
		filesCreated.push(specPath);

		const specTitle = (jsonData.info as Record<string, unknown> | undefined)?.title?.toString() || baseName;
		openApiSpecs.push({ name: specName, specPath, title: specTitle });

		// Generate API docs HTML for the spec
		const apiDocsHtml = templates.generateApiDocsHtml(`/api-docs-${specName}.json`);
		const htmlPath = `public/api-docs-${specName}.html`;
		await writeFile(resolvePath(outputDir, htmlPath), apiDocsHtml.content);
		filesCreated.push(htmlPath);
	}

	return openApiSpecs;
}

/**
 * Write input pages to content directory
 */
async function writeInputPages(
	pages: Array<PageConfig>,
	outputDir: string,
	filesCreated: Array<string>,
): Promise<void> {
	for (const page of pages) {
		const pagePath = resolvePath(outputDir, `content/${page.path}.mdx`);
		await writeFile(pagePath, page.content);
		filesCreated.push(`content/${page.path}.mdx`);
	}
}

/**
 * Generate a Nextra site using App Router (Nextra 4.x)
 */
export async function generateAppRouterSite(config: GeneratorConfig): Promise<GeneratorResult> {
	const filesCreated: Array<string> = [];
	const errors: Array<string> = [];

	// Derive siteName from output directory for default project link and branding
	const siteName = path.basename(config.outputDir);
	const theme = { ...DEFAULT_THEME, ...config.theme };

	// Determine if we have input content
	const hasInputFiles = config.inputFiles && config.inputFiles.length > 0;
	const hasOpenApi = config.openApi && config.openApi.length > 0;
	const hasCustomPages = config.pages && config.pages.length > 0;
	const hasContent = hasInputFiles || hasOpenApi || hasCustomPages;

	// By default, create minimal site. Only create sample pages if explicitly NOT skipping
	// and skipDefaultPages is explicitly set to false (not undefined)
	const createSamplePages = config.skipDefaultPages === false && !hasContent;

	try {
		// Generate base template files (pass siteName for default project link)
		// Pass true for minimalContent when we DON'T want sample pages
		const baseTemplates = templates.getBaseTemplates(theme, !createSamplePages, siteName);

		for (const template of baseTemplates) {
			const filePath = resolvePath(config.outputDir, template.path);
			await writeFile(filePath, template.content);
			filesCreated.push(template.path);
		}

		// Only generate default sample pages if explicitly requested
		if (createSamplePages) {
			// Generate getting-started page
			const gettingStartedPath = resolvePath(config.outputDir, "content/getting-started.mdx");
			await writeFile(
				gettingStartedPath,
				`# Getting Started

Welcome! This guide will help you get up and running quickly.

## Prerequisites

- Node.js 18+
- npm or yarn

## Installation

\`\`\`bash
npm install
\`\`\`

## Quick Start

\`\`\`bash
npm run dev
\`\`\`

Visit [http://localhost:3000](http://localhost:3000) to see your site.
`,
			);
			filesCreated.push("content/getting-started.mdx");

			// Generate API reference section
			const apiRefMetaPath = resolvePath(config.outputDir, "content/api-reference/_meta.ts");
			await writeFile(
				apiRefMetaPath,
				`export default {
  index: 'Overview',
  interactive: 'Interactive API'
}
`,
			);
			filesCreated.push("content/api-reference/_meta.ts");

			const apiRefIndexPath = resolvePath(config.outputDir, "content/api-reference/index.mdx");
			await writeFile(
				apiRefIndexPath,
				`# API Reference

API documentation overview.

## Interactive Documentation

Try out our API endpoints interactively on the [Interactive API](/api-reference/interactive) page.
`,
			);
			filesCreated.push("content/api-reference/index.mdx");

			const apiRefInteractivePath = resolvePath(config.outputDir, "content/api-reference/interactive.mdx");
			await writeFile(
				apiRefInteractivePath,
				`import ApiReference from '../../components/ApiReference'

# Interactive API Documentation

Explore and test our API endpoints directly in your browser.

<ApiReference />
`,
			);
			filesCreated.push("content/api-reference/interactive.mdx");
		}

		// Generate custom pages
		if (config.pages && config.pages.length > 0) {
			for (const page of config.pages) {
				const pagePath = resolvePath(config.outputDir, `content/${page.path}.mdx`);
				await writeFile(pagePath, page.content);
				filesCreated.push(`content/${page.path}.mdx`);
			}
		}

		// Track OpenAPI specs for JOLLI-192 (API docs page generation)
		const openApiSpecs: Array<OpenApiSpecInfo> = [];

		// Handle OpenAPI specs from --openapi flag (JOLLI-191/192 pattern)
		if (config.openApi && config.openApi.length > 0) {
			for (const openApiConfig of config.openApi) {
				try {
					const spec = await loadOpenApiSpec(openApiConfig.specPath);
					const specName = slugify(path.basename(openApiConfig.specPath));
					const specTitle = spec.info?.title || path.basename(openApiConfig.specPath);

					// Copy OpenAPI spec to public folder with slugified name
					const specPath = `public/api-docs-${specName}.json`;
					const specDestPath = resolvePath(config.outputDir, specPath);
					await writeFile(specDestPath, JSON.stringify(spec, null, 2));
					filesCreated.push(specPath);

					openApiSpecs.push({ name: specName, specPath, title: specTitle });

					// Generate API docs HTML for the spec
					const apiDocsHtml = templates.generateApiDocsHtml(`/api-docs-${specName}.json`);
					const htmlPath = `public/api-docs-${specName}.html`;
					await writeFile(resolvePath(config.outputDir, htmlPath), apiDocsHtml.content);
					filesCreated.push(htmlPath);
				} catch (err) {
					errors.push(`Failed to process OpenAPI spec: ${err}`);
				}
			}
		}

		// Process input files (mdx, md, json)
		let inputPages: Array<PageConfig> = [];
		if (config.inputFiles && config.inputFiles.length > 0) {
			const { pages, jsonFiles, errors: inputErrors } = await processInputFiles(config.inputFiles, "app");
			inputPages = pages;

			// Add any processing errors
			errors.push(...inputErrors);

			// Write processed pages
			await writeInputPages(inputPages, config.outputDir, filesCreated);

			// Process OpenAPI JSON files from input directory
			const inputOpenApiSpecs = await processOpenApiJsonFiles(jsonFiles, config.outputDir, filesCreated);
			openApiSpecs.push(...inputOpenApiSpecs);
		}

		// Generate navbar meta and root redirect (JOLLI-191/192)
		// This applies to both --openapi flag and input files with OpenAPI specs
		const firstPageSlug = inputPages.length > 0 ? Object.keys(buildNavigationMeta(inputPages))[0] || null : null;

		if (inputPages.length > 0 || openApiSpecs.length > 0) {
			// Generate _meta.ts with hidden index, article entries, and API Reference
			// Uses shared buildFullNavigationMeta to match memory.ts behavior
			const navMeta = buildFullNavigationMeta(inputPages, openApiSpecs);
			const metaFile = templates.generateContentMeta(navMeta);
			const metaPath = resolvePath(config.outputDir, metaFile.path);
			await writeFile(metaPath, metaFile.content);
			filesCreated.push(metaFile.path);

			// JOLLI-191: Generate app/page.tsx with redirect to first article or first API doc
			if (firstPageSlug) {
				const rootRedirectPage = templates.generateRootRedirectPage(firstPageSlug);
				await writeFile(resolvePath(config.outputDir, rootRedirectPage.path), rootRedirectPage.content);
				filesCreated.push(rootRedirectPage.path);
			} else if (openApiSpecs.length > 0) {
				// No articles but has API docs - redirect to first API doc
				const firstApiSlug = openApiSpecs[0].name;
				const rootRedirectPage = templates.generateRootRedirectPage(`api-docs/${firstApiSlug}`);
				await writeFile(resolvePath(config.outputDir, rootRedirectPage.path), rootRedirectPage.content);
				filesCreated.push(rootRedirectPage.path);
			}
		}

		// JOLLI-192: Generate app/api-docs/[[...slug]]/page.tsx for OpenAPI specs
		// Split into server component (page.tsx) and client component (ApiReference.tsx)
		// because Next.js 15 doesn't allow 'use client' and generateStaticParams in the same file
		if (openApiSpecs.length > 0) {
			const apiDocsSlugs = openApiSpecs.map(spec => spec.name);
			const apiDocsPage = templates.generateApiDocsPage(apiDocsSlugs);
			await writeFile(resolvePath(config.outputDir, apiDocsPage.path), apiDocsPage.content);
			filesCreated.push(apiDocsPage.path);

			const apiReference = templates.generateApiReferenceComponent();
			await writeFile(resolvePath(config.outputDir, apiReference.path), apiReference.content);
			filesCreated.push(apiReference.path);
		}

		const result: GeneratorResult = {
			success: true,
			outputDir: config.outputDir,
			filesCreated,
		};
		if (errors.length > 0) {
			result.errors = errors;
		}
		return result;
	} catch (err) {
		return {
			success: false,
			outputDir: config.outputDir,
			filesCreated,
			errors: [`Generation failed: ${err}`],
		};
	}
}
