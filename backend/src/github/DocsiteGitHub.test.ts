import { createDocsiteGitHub } from "./DocsiteGitHub";
import type { Octokit } from "@octokit/rest";
import { beforeEach, describe, expect, test, vi } from "vitest";

// Mock the Logger - use hoisted pattern for vi.mock compatibility
const mockLogInfo = vi.hoisted(() => vi.fn());
vi.mock("../util/Logger", () => ({
	getLog: () => ({
		info: mockLogInfo,
		debug: vi.fn(),
		warn: vi.fn(),
		error: vi.fn(),
	}),
}));

// Mock Octokit methods
const mockCreateInOrg = vi.fn();
const mockGetRef = vi.fn();
const mockGetCommit = vi.fn();
const mockCreateTree = vi.fn();
const mockCreateCommit = vi.fn();
const mockUpdateRef = vi.fn();
const mockDelete = vi.fn();
const mockGetTree = vi.fn();
const mockGetBlob = vi.fn();
const mockCreateBlob = vi.fn();

const mockOctokit = {
	rest: {
		repos: {
			createInOrg: mockCreateInOrg,
			delete: mockDelete,
		},
		git: {
			getRef: mockGetRef,
			getCommit: mockGetCommit,
			createTree: mockCreateTree,
			createCommit: mockCreateCommit,
			updateRef: mockUpdateRef,
			getTree: mockGetTree,
			getBlob: mockGetBlob,
			createBlob: mockCreateBlob,
		},
	},
} as unknown as Octokit;

beforeEach(() => {
	vi.clearAllMocks();
	mockCreateInOrg.mockClear();
	mockGetRef.mockClear();
	mockGetCommit.mockClear();
	mockCreateTree.mockClear();
	mockCreateCommit.mockClear();
	mockUpdateRef.mockClear();
	mockDelete.mockClear();
	mockGetTree.mockClear();
	mockGetBlob.mockClear();
	mockCreateBlob.mockClear();
	mockLogInfo.mockClear();
});

describe("createDocsiteGitHub", () => {
	describe("createRepository", () => {
		test("creates a public repository in organization", async () => {
			const mockCloneUrl = "https://github.com/test-org/test-repo.git";
			mockCreateInOrg.mockResolvedValue({
				data: { clone_url: mockCloneUrl },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const result = await github.createRepository("test-org", "test-repo", false);

			expect(mockCreateInOrg).toHaveBeenCalledWith({
				org: "test-org",
				name: "test-repo",
				private: false,
				auto_init: true,
				description: "Docusaurus documentation site generated by Jolli",
			});
			expect(result).toBe(mockCloneUrl);
		});

		test("creates a private repository in organization", async () => {
			const mockCloneUrl = "https://github.com/test-org/private-repo.git";
			mockCreateInOrg.mockResolvedValue({
				data: { clone_url: mockCloneUrl },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const result = await github.createRepository("test-org", "private-repo", true);

			expect(mockCreateInOrg).toHaveBeenCalledWith({
				org: "test-org",
				name: "private-repo",
				private: true,
				auto_init: true,
				description: "Docusaurus documentation site generated by Jolli",
			});
			expect(result).toBe(mockCloneUrl);
		});

		test("logs audit event for public repository creation", async () => {
			const mockCloneUrl = "https://github.com/test-org/test-repo.git";
			mockCreateInOrg.mockResolvedValue({
				data: { clone_url: mockCloneUrl },
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.createRepository("test-org", "test-repo", false);

			expect(mockLogInfo).toHaveBeenCalledWith(
				{ action: "github_repo_created", org: "test-org", repo: "test-repo", visibility: "public" },
				"Created GitHub repository %s/%s (visibility: %s)",
				"test-org",
				"test-repo",
				"public",
			);
		});

		test("logs audit event for private repository creation", async () => {
			const mockCloneUrl = "https://github.com/test-org/private-repo.git";
			mockCreateInOrg.mockResolvedValue({
				data: { clone_url: mockCloneUrl },
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.createRepository("test-org", "private-repo", true);

			expect(mockLogInfo).toHaveBeenCalledWith(
				{ action: "github_repo_created", org: "test-org", repo: "private-repo", visibility: "private" },
				"Created GitHub repository %s/%s (visibility: %s)",
				"test-org",
				"private-repo",
				"private",
			);
		});

		test("throws specific error when repository already exists (409)", async () => {
			const error = { status: 409, message: "Repository already exists" };
			mockCreateInOrg.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.createRepository("test-org", "existing-repo", false)).rejects.toThrow(
				"Repository test-org/existing-repo already exists",
			);

			expect(mockCreateInOrg).toHaveBeenCalledWith({
				org: "test-org",
				name: "existing-repo",
				private: false,
				auto_init: true,
				description: "Docusaurus documentation site generated by Jolli",
			});
		});

		test("throws original error for non-409 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockCreateInOrg.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.createRepository("test-org", "test-repo", false)).rejects.toEqual(error);
		});

		test("throws original error when error has no status property", async () => {
			const error = new Error("Network error");
			mockCreateInOrg.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.createRepository("test-org", "test-repo", false)).rejects.toThrow("Network error");
		});

		test("handles null/undefined errors", async () => {
			mockCreateInOrg.mockRejectedValue(null);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.createRepository("test-org", "test-repo", false)).rejects.toBeNull();
		});
	});

	describe("uploadDocusaurusProject", () => {
		const mockRefSha = "ref-sha-123";
		const _mockCommitSha = "commit-sha-456";
		const mockTreeSha = "tree-sha-789";
		const mockNewTreeSha = "new-tree-sha-abc";
		const mockNewCommitSha = "new-commit-sha-def";

		beforeEach(() => {
			// Set up successful flow by default
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("uploads Docusaurus project with multiple files", async () => {
			const files = [
				{ path: "package.json", content: '{"name": "docs"}' },
				{ path: "docs/intro.md", content: "# Introduction" },
				{ path: "docusaurus.config.js", content: "module.exports = {}" },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			// Verify the full workflow
			expect(mockGetRef).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				ref: "heads/main",
			});

			expect(mockGetCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				commit_sha: mockRefSha,
			});

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "package.json",
						mode: "100644",
						type: "blob",
						content: '{"name": "docs"}',
					},
					{
						path: "docs/intro.md",
						mode: "100644",
						type: "blob",
						content: "# Introduction",
					},
					{
						path: "docusaurus.config.js",
						mode: "100644",
						type: "blob",
						content: "module.exports = {}",
					},
				],
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Add Docusaurus documentation site",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});

			expect(mockUpdateRef).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				ref: "heads/main",
				sha: mockNewCommitSha,
			});
		});

		test("uploads empty file list", async () => {
			const files: Array<{ path: string; content: string }> = [];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [],
				base_tree: mockTreeSha,
			});
		});

		test("uploads single file", async () => {
			const files = [{ path: "README.md", content: "# Documentation" }];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "README.md",
						mode: "100644",
						type: "blob",
						content: "# Documentation",
					},
				],
				base_tree: mockTreeSha,
			});
		});

		test("throws specific error when repository not found (404)", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "nonexistent-repo", files)).rejects.toThrow(
				"Repository test-owner/nonexistent-repo not found",
			);
		});

		test("throws specific error when repository not found during commit", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetCommit.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toThrow(
				"Repository test-owner/test-repo not found",
			);
		});

		test("throws specific error when repository not found during tree creation", async () => {
			const error = { status: 404, message: "Not Found" };
			mockCreateTree.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toThrow(
				"Repository test-owner/test-repo not found",
			);
		});

		test("throws original error for non-404 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toEqual(error);
		});

		test("handles error during tree creation with non-404 status", async () => {
			const error = { status: 403, message: "Forbidden" };
			mockCreateTree.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toEqual(error);
		});

		test("handles error during commit creation", async () => {
			const error = { status: 422, message: "Validation Failed" };
			mockCreateCommit.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toEqual(error);
		});

		test("handles error during ref update", async () => {
			const error = { status: 422, message: "Validation Failed" };
			mockUpdateRef.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toEqual(error);
		});

		test("handles errors without status property", async () => {
			const error = new Error("Network error");
			mockGetRef.mockRejectedValue(error);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toThrow(
				"Network error",
			);
		});

		test("handles null/undefined errors", async () => {
			mockGetRef.mockRejectedValue(null);

			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.uploadDocusaurusProject("test-owner", "test-repo", files)).rejects.toBeNull();
		});

		test("preserves base tree when uploading files", async () => {
			const files = [{ path: "docs/new.md", content: "# New Doc" }];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			// Verify base_tree is passed to preserve existing files like README
			expect(mockCreateTree).toHaveBeenCalledWith(
				expect.objectContaining({
					base_tree: mockTreeSha,
				}),
			);
		});

		test("uses correct file mode and type for all files", async () => {
			const files = [
				{ path: "file1.txt", content: "content1" },
				{ path: "file2.md", content: "content2" },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "file1.txt",
						mode: "100644",
						type: "blob",
						content: "content1",
					},
					{
						path: "file2.md",
						mode: "100644",
						type: "blob",
						content: "content2",
					},
				],
				base_tree: mockTreeSha,
			});
		});

		test("creates commit with correct message", async () => {
			const files = [{ path: "README.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Add Docusaurus documentation site",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("creates blobs for base64-encoded binary files", async () => {
			const mockBlobSha = "blob-sha-for-binary";
			mockCreateBlob.mockResolvedValue({
				data: { sha: mockBlobSha },
			});

			const files = [
				{ path: "docs/intro.md", content: "# Introduction" },
				{ path: "public/images/logo.png", content: "iVBORw0KGgoAAAANS", encoding: "base64" as const },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			// Verify blob was created for binary file
			expect(mockCreateBlob).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				content: "iVBORw0KGgoAAAANS",
				encoding: "base64",
			});

			// Verify tree includes both text (inline content) and binary (blob sha) entries
			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "docs/intro.md",
						mode: "100644",
						type: "blob",
						content: "# Introduction",
					},
					{
						path: "public/images/logo.png",
						mode: "100644",
						type: "blob",
						sha: mockBlobSha,
					},
				],
				base_tree: mockTreeSha,
			});
		});

		test("handles multiple binary files", async () => {
			mockCreateBlob
				.mockResolvedValueOnce({ data: { sha: "blob-sha-1" } })
				.mockResolvedValueOnce({ data: { sha: "blob-sha-2" } });

			const files = [
				{ path: "public/images/logo.png", content: "base64data1", encoding: "base64" as const },
				{ path: "public/images/icon.jpg", content: "base64data2", encoding: "base64" as const },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProject("test-owner", "test-repo", files);

			expect(mockCreateBlob).toHaveBeenCalledTimes(2);
			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{ path: "public/images/logo.png", mode: "100644", type: "blob", sha: "blob-sha-1" },
					{ path: "public/images/icon.jpg", mode: "100644", type: "blob", sha: "blob-sha-2" },
				],
				base_tree: mockTreeSha,
			});
		});
	});

	describe("downloadRepository", () => {
		test("downloads repository files successfully", async () => {
			const mockRefSha = "ref-sha-123";
			const mockTreeSha = "tree-sha-789";

			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});

			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});

			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "README.md" },
						{ type: "blob", sha: "blob2", path: "src/index.ts" },
						{ type: "tree", sha: "tree1", path: "docs" }, // Directory - should skip
					],
				},
			});

			mockGetBlob
				.mockResolvedValueOnce({
					data: { content: Buffer.from("# README").toString("base64") },
				})
				.mockResolvedValueOnce({
					data: { content: Buffer.from("console.log('hello')").toString("base64") },
				});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.downloadRepository("test-owner", "test-repo");

			expect(files).toHaveLength(2);
			expect(files[0]).toEqual({ path: "README.md", content: "# README" });
			expect(files[1]).toEqual({ path: "src/index.ts", content: "console.log('hello')" });

			expect(mockGetRef).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				ref: "heads/main",
			});

			expect(mockGetCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				commit_sha: mockRefSha,
			});

			expect(mockGetTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree_sha: mockTreeSha,
				recursive: "true",
			});

			expect(mockGetBlob).toHaveBeenCalledTimes(2);
		});

		test("returns empty array when repository has no files", async () => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: "ref-sha" } },
			});

			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: "tree-sha" } },
			});

			mockGetTree.mockResolvedValue({
				data: { tree: [] },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.downloadRepository("test-owner", "empty-repo");

			expect(files).toEqual([]);
			expect(mockGetBlob).not.toHaveBeenCalled();
		});

		test("skips directories and only downloads blobs", async () => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: "ref-sha" } },
			});

			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: "tree-sha" } },
			});

			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "tree", sha: "tree1", path: "src" },
						{ type: "tree", sha: "tree2", path: "docs" },
						{ type: "blob", sha: "blob1", path: "README.md" },
					],
				},
			});

			mockGetBlob.mockResolvedValue({
				data: { content: Buffer.from("# Test").toString("base64") },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.downloadRepository("test-owner", "test-repo");

			expect(files).toHaveLength(1);
			expect(mockGetBlob).toHaveBeenCalledTimes(1);
		});

		test("throws specific error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.downloadRepository("test-owner", "nonexistent-repo")).rejects.toThrow(
				"Repository test-owner/nonexistent-repo not found",
			);
		});

		test("throws original error for non-404 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.downloadRepository("test-owner", "test-repo")).rejects.toEqual(error);
		});

		test("downloads from specific commit SHA when provided", async () => {
			const specificCommitSha = "specific-commit-sha-123";
			const mockTreeSha = "tree-sha-789";

			// getRef should NOT be called when commitSha is provided
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});

			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "blob1", path: "README.md" }],
				},
			});

			mockGetBlob.mockResolvedValue({
				data: { content: Buffer.from("# Test Content").toString("base64") },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.downloadRepository("test-owner", "test-repo", specificCommitSha);

			// Verify getRef was NOT called (since we provided a specific commit SHA)
			expect(mockGetRef).not.toHaveBeenCalled();

			// Verify getCommit was called with the specific commit SHA
			expect(mockGetCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				commit_sha: specificCommitSha,
			});

			expect(files).toHaveLength(1);
			expect(files[0]).toEqual({ path: "README.md", content: "# Test Content" });
		});

		test("preserves binary files as base64 encoded", async () => {
			const mockRefSha = "ref-sha-123";
			const mockTreeSha = "tree-sha-789";
			// PNG header bytes
			const pngBytes = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
			const pngBase64 = pngBytes.toString("base64");

			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});

			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});

			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "README.md" },
						{ type: "blob", sha: "blob2", path: "public/images/logo.png" },
					],
				},
			});

			mockGetBlob
				.mockResolvedValueOnce({
					data: { content: Buffer.from("# README").toString("base64") },
				})
				.mockResolvedValueOnce({
					// GitHub returns base64 with newlines for large files
					data: { content: `${pngBase64}\n` },
				});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.downloadRepository("test-owner", "test-repo");

			expect(files).toHaveLength(2);
			// Text file: decoded to UTF-8
			expect(files[0]).toEqual({ path: "README.md", content: "# README" });
			// Binary file: kept as base64 with encoding marker
			expect(files[1]).toEqual({
				path: "public/images/logo.png",
				content: pngBase64,
				encoding: "base64",
			});
		});
	});

	describe("deleteRepository", () => {
		test("deletes repository successfully", async () => {
			mockDelete.mockResolvedValue({});

			const github = createDocsiteGitHub(mockOctokit);
			await github.deleteRepository("test-owner", "test-repo");

			expect(mockDelete).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
			});
		});

		test("handles repository not found (404) as success", async () => {
			const error = { status: 404, message: "Not Found" };
			mockDelete.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			// Should not throw - repository already deleted
			await expect(github.deleteRepository("test-owner", "nonexistent-repo")).resolves.toBeUndefined();

			expect(mockDelete).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "nonexistent-repo",
			});
		});

		test("throws specific error when token lacks delete_repo permission (403)", async () => {
			const error = { status: 403, message: "Forbidden" };
			mockDelete.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.deleteRepository("test-owner", "test-repo")).rejects.toThrow(
				"GitHub token does not have permission to delete repositories. " +
					"Please add the 'delete_repo' scope to your GitHub token. " +
					"Repository test-owner/test-repo must be deleted manually.",
			);
		});

		test("throws original error for non-404/403 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockDelete.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.deleteRepository("test-owner", "test-repo")).rejects.toEqual(error);
		});

		test("throws original error when error has no status property", async () => {
			const error = new Error("Network error");
			mockDelete.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.deleteRepository("test-owner", "test-repo")).rejects.toThrow("Network error");
		});
	});

	describe("getConsistencyCheckData", () => {
		test("returns file paths and _meta.ts content when file exists", async () => {
			const mockRefSha = "ref-sha-123";
			const mockTreeSha = "tree-sha-789";
			const mockMetaSha = "meta-sha-456";

			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "README.md" },
						{ type: "blob", sha: mockMetaSha, path: "content/_meta.ts" },
						{ type: "blob", sha: "blob2", path: "content/article1.mdx" },
						{ type: "tree", sha: "tree1", path: "content" },
					],
				},
			});
			mockGetBlob.mockResolvedValue({
				data: { content: Buffer.from('export default { "article1": "Article 1" };').toString("base64") },
			});

			const github = createDocsiteGitHub(mockOctokit);
			const result = await github.getConsistencyCheckData("test-owner", "test-repo");

			expect(result.filePaths).toEqual(["README.md", "content/_meta.ts", "content/article1.mdx"]);
			expect(result.metaContent).toBe('export default { "article1": "Article 1" };');

			// Verify only one blob was fetched (just _meta.ts)
			expect(mockGetBlob).toHaveBeenCalledTimes(1);
			expect(mockGetBlob).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				file_sha: mockMetaSha,
			});
		});

		test("returns file paths without metaContent when _meta.ts does not exist", async () => {
			const mockRefSha = "ref-sha-123";
			const mockTreeSha = "tree-sha-789";

			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "README.md" },
						{ type: "blob", sha: "blob2", path: "content/article1.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			const result = await github.getConsistencyCheckData("test-owner", "test-repo");

			expect(result.filePaths).toEqual(["README.md", "content/article1.mdx"]);
			expect(result.metaContent).toBeUndefined();

			// Verify no blob was fetched since there's no _meta.ts
			expect(mockGetBlob).not.toHaveBeenCalled();
		});

		test("throws error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.getConsistencyCheckData("test-owner", "nonexistent-repo")).rejects.toThrow(
				"Repository test-owner/nonexistent-repo not found",
			);
		});

		test("throws original error for non-404 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.getConsistencyCheckData("test-owner", "test-repo")).rejects.toEqual(error);
		});
	});

	describe("updateRepositoryFile", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockBlobSha = "blob-sha-abc";
		const mockNewTreeSha = "new-tree-sha-def";
		const mockNewCommitSha = "new-commit-sha-ghi";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockCreateBlob.mockResolvedValue({
				data: { sha: mockBlobSha },
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("updates a file successfully", async () => {
			const github = createDocsiteGitHub(mockOctokit);
			await github.updateRepositoryFile(
				"test-owner",
				"test-repo",
				"src/config.json",
				'{"key": "value"}',
				"Update config",
			);

			expect(mockGetRef).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				ref: "heads/main",
			});

			expect(mockCreateBlob).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				content: '{"key": "value"}',
				encoding: "utf-8",
			});

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "src/config.json",
						mode: "100644",
						type: "blob",
						sha: mockBlobSha,
					},
				],
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Update config",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});

			expect(mockUpdateRef).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				ref: "heads/main",
				sha: mockNewCommitSha,
			});
		});

		test("throws error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.updateRepositoryFile("test-owner", "nonexistent", "file.txt", "content", "Update"),
			).rejects.toThrow("Repository test-owner/nonexistent or file file.txt not found");
		});
	});

	describe("uploadDocusaurusProjectPreservingNonMdFiles", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockNewTreeSha = "new-tree-sha-abc";
		const mockNewCommitSha = "new-commit-sha-def";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "docs/old-article.md" },
						{ type: "blob", sha: "blob2", path: "docs/article-to-keep.mdx" },
						{ type: "blob", sha: "blob3", path: "custom/script.js" },
						{ type: "blob", sha: "blob4", path: "README.md" },
					],
				},
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("preserves non-MD/MDX files while updating MD/MDX files and returns commit SHA", async () => {
			const newFiles = [
				{ path: "docs/article-to-keep.mdx", content: "# Updated Article" },
				{ path: "docs/new-article.md", content: "# New Article" },
			];

			const github = createDocsiteGitHub(mockOctokit);
			const commitSha = await github.uploadDocusaurusProjectPreservingNonMdFiles(
				"test-owner",
				"test-repo",
				newFiles,
			);

			// Verify the returned commit SHA
			expect(commitSha).toBe(mockNewCommitSha);

			// Verify tree creation includes new files and deletion entries for old MD/MDX files
			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: expect.arrayContaining([
					{
						path: "docs/article-to-keep.mdx",
						mode: "100644",
						type: "blob",
						content: "# Updated Article",
					},
					{
						path: "docs/new-article.md",
						mode: "100644",
						type: "blob",
						content: "# New Article",
					},
					// Old MD file should be marked for deletion
					expect.objectContaining({
						path: "docs/old-article.md",
						sha: null,
					}),
				]),
				base_tree: mockTreeSha,
			});

			// Verify commit message
			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Update documentation (preserve custom files)",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("throws error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const files = [{ path: "docs/test.md", content: "# Test" }];

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.uploadDocusaurusProjectPreservingNonMdFiles("test-owner", "nonexistent", files),
			).rejects.toThrow("Repository test-owner/nonexistent not found");
		});

		test("deletes additional files that exist in repository", async () => {
			// Add JSON/YAML files to the mock tree
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "docs/article.md" },
						{ type: "blob", sha: "blob2", path: "public/api-spec.json" },
						{ type: "blob", sha: "blob3", path: "public/api-docs-api-spec.html" },
						{ type: "blob", sha: "blob4", path: "pages/config.yaml" },
					],
				},
			});

			const newFiles = [{ path: "docs/article.md", content: "# Updated Article" }];
			const additionalPathsToDelete = [
				"public/api-spec.json",
				"public/api-docs-api-spec.html",
				"pages/config.yaml",
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles(
				"test-owner",
				"test-repo",
				newFiles,
				additionalPathsToDelete,
			);

			// Verify tree creation includes deletion entries for additional files
			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: expect.arrayContaining([
					// New file content
					{
						path: "docs/article.md",
						mode: "100644",
						type: "blob",
						content: "# Updated Article",
					},
					// Additional files marked for deletion
					{ path: "public/api-spec.json", mode: "100644", type: "blob", sha: null },
					{ path: "public/api-docs-api-spec.html", mode: "100644", type: "blob", sha: null },
					{ path: "pages/config.yaml", mode: "100644", type: "blob", sha: null },
				]),
				base_tree: mockTreeSha,
			});
		});

		test("ignores additional paths that do not exist in repository", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "docs/article.md" },
						{ type: "blob", sha: "blob2", path: "public/existing-file.json" },
					],
				},
			});

			const newFiles = [{ path: "docs/article.md", content: "# Updated" }];
			// Request deletion of files that don't exist
			const additionalPathsToDelete = ["public/nonexistent-file.json", "public/existing-file.json"];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles(
				"test-owner",
				"test-repo",
				newFiles,
				additionalPathsToDelete,
			);

			const createTreeCall = mockCreateTree.mock.calls[0][0];
			const deletionEntries = createTreeCall.tree.filter((entry: { sha: string | null }) => entry.sha === null);

			// Should only have deletion entry for existing-file.json, not nonexistent-file.json
			expect(deletionEntries).toHaveLength(1);
			expect(deletionEntries[0].path).toBe("public/existing-file.json");
		});

		test("ignores additional paths that are in the new files list", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "docs/article.md" },
						{ type: "blob", sha: "blob2", path: "public/api-spec.json" },
					],
				},
			});

			// File is being updated, not deleted
			const newFiles = [
				{ path: "docs/article.md", content: "# Updated" },
				{ path: "public/api-spec.json", content: '{"openapi": "3.0.0"}' },
			];
			// Request deletion of the same file that's being updated
			const additionalPathsToDelete = ["public/api-spec.json"];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles(
				"test-owner",
				"test-repo",
				newFiles,
				additionalPathsToDelete,
			);

			const createTreeCall = mockCreateTree.mock.calls[0][0];

			// Should have the new file content, not a deletion
			const apiSpecEntries = createTreeCall.tree.filter(
				(entry: { path: string }) => entry.path === "public/api-spec.json",
			);
			expect(apiSpecEntries).toHaveLength(1);
			expect(apiSpecEntries[0].content).toBe('{"openapi": "3.0.0"}');
			expect(apiSpecEntries[0].sha).toBeUndefined(); // Not a deletion
		});

		test("handles empty additionalPathsToDelete array", async () => {
			const newFiles = [{ path: "docs/article.md", content: "# Updated" }];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles("test-owner", "test-repo", newFiles, []);

			// Should work normally without any additional deletions
			expect(mockCreateTree).toHaveBeenCalled();
			expect(mockCreateCommit).toHaveBeenCalled();
		});

		test("creates blobs for base64-encoded binary files", async () => {
			const mockBlobSha = "blob-sha-for-image";
			mockCreateBlob.mockResolvedValue({
				data: { sha: mockBlobSha },
			});

			const newFiles = [
				{ path: "docs/article.md", content: "# Article with image" },
				{ path: "public/images/screenshot.png", content: "iVBORw0KGgoAAAANS", encoding: "base64" as const },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles("test-owner", "test-repo", newFiles);

			// Verify blob was created for binary file
			expect(mockCreateBlob).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				content: "iVBORw0KGgoAAAANS",
				encoding: "base64",
			});

			// Verify tree includes text file with content and binary file with sha
			const createTreeCall = mockCreateTree.mock.calls[0][0];
			const textEntry = createTreeCall.tree.find((entry: { path: string }) => entry.path === "docs/article.md");
			const binaryEntry = createTreeCall.tree.find(
				(entry: { path: string }) => entry.path === "public/images/screenshot.png",
			);

			expect(textEntry).toEqual({
				path: "docs/article.md",
				mode: "100644",
				type: "blob",
				content: "# Article with image",
			});
			expect(binaryEntry).toEqual({
				path: "public/images/screenshot.png",
				mode: "100644",
				type: "blob",
				sha: mockBlobSha,
			});
		});

		test("handles mix of text and binary files with deletions", async () => {
			mockCreateBlob.mockResolvedValue({
				data: { sha: "image-blob-sha" },
			});

			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "docs/old-article.md" },
						{ type: "blob", sha: "blob2", path: "public/old-image.png" },
					],
				},
			});

			const newFiles = [
				{ path: "docs/new-article.md", content: "# New Article" },
				{ path: "public/images/new-image.png", content: "newimagedata", encoding: "base64" as const },
			];

			const github = createDocsiteGitHub(mockOctokit);
			await github.uploadDocusaurusProjectPreservingNonMdFiles("test-owner", "test-repo", newFiles);

			const createTreeCall = mockCreateTree.mock.calls[0][0];

			// Should have: new text file, new binary file, and deletion of old MD file
			expect(createTreeCall.tree).toContainEqual({
				path: "docs/new-article.md",
				mode: "100644",
				type: "blob",
				content: "# New Article",
			});
			expect(createTreeCall.tree).toContainEqual({
				path: "public/images/new-image.png",
				mode: "100644",
				type: "blob",
				sha: "image-blob-sha",
			});
			expect(createTreeCall.tree).toContainEqual({
				path: "docs/old-article.md",
				mode: "100644",
				type: "blob",
				sha: null,
			});
		});
	});

	describe("createFolder", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockBlobSha = "blob-sha-abc";
		const mockNewTreeSha = "new-tree-sha-def";
		const mockNewCommitSha = "new-commit-sha-ghi";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockCreateBlob.mockResolvedValue({
				data: { sha: mockBlobSha },
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("creates .gitkeep file in folder", async () => {
			const github = createDocsiteGitHub(mockOctokit);
			await github.createFolder("test-owner", "test-repo", "content/guides");

			expect(mockCreateBlob).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				content: "",
				encoding: "utf-8",
			});

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{
						path: "content/guides/.gitkeep",
						mode: "100644",
						type: "blob",
						sha: mockBlobSha,
					},
				],
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Create folder content/guides",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("normalizes path with trailing slash", async () => {
			const github = createDocsiteGitHub(mockOctokit);
			await github.createFolder("test-owner", "test-repo", "content/guides/");

			expect(mockCreateTree).toHaveBeenCalledWith(
				expect.objectContaining({
					tree: [
						expect.objectContaining({
							path: "content/guides/.gitkeep",
						}),
					],
				}),
			);
		});
	});

	describe("listFolderContents", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
		});

		test("returns files in folder", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" },
						{ type: "blob", sha: "blob2", path: "content/guides/advanced.mdx" },
						{ type: "blob", sha: "blob3", path: "content/other.mdx" },
						{ type: "tree", sha: "tree1", path: "content/guides" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.listFolderContents("test-owner", "test-repo", "content/guides");

			expect(files).toEqual(["content/guides/intro.mdx", "content/guides/advanced.mdx"]);
		});

		test("returns empty array when no files match", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "content/other.mdx" },
						{ type: "tree", sha: "tree1", path: "content" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.listFolderContents("test-owner", "test-repo", "content/guides");

			expect(files).toEqual([]);
		});

		test("filters nested files correctly", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" },
						{ type: "blob", sha: "blob2", path: "content/guides/nested/deep.mdx" },
						{ type: "blob", sha: "blob3", path: "content/guides-other/file.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.listFolderContents("test-owner", "test-repo", "content/guides");

			// Should include nested files but not files from similarly-named folders
			expect(files).toEqual(["content/guides/intro.mdx", "content/guides/nested/deep.mdx"]);
		});

		test("throws error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.listFolderContents("test-owner", "nonexistent", "content")).rejects.toThrow(
				"Repository test-owner/nonexistent not found",
			);
		});

		test("throws original error for non-404 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.listFolderContents("test-owner", "test-repo", "content")).rejects.toEqual(error);
		});

		test("normalizes path with trailing slash", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" }],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			const files = await github.listFolderContents("test-owner", "test-repo", "content/guides/");

			expect(files).toEqual(["content/guides/intro.mdx"]);
		});
	});

	describe("deleteFolder", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockNewTreeSha = "new-tree-sha-abc";
		const mockNewCommitSha = "new-commit-sha-def";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("deletes all files in folder", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" },
						{ type: "blob", sha: "blob2", path: "content/guides/advanced.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.deleteFolder("test-owner", "test-repo", "content/guides");

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{ path: "content/guides/intro.mdx", mode: "100644", type: "blob", sha: null },
					{ path: "content/guides/advanced.mdx", mode: "100644", type: "blob", sha: null },
				],
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Delete folder content/guides",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("returns early when folder is empty", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "blob1", path: "content/other.mdx" }],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.deleteFolder("test-owner", "test-repo", "content/guides");

			// Should not create a commit when folder is empty
			expect(mockCreateTree).not.toHaveBeenCalled();
			expect(mockCreateCommit).not.toHaveBeenCalled();
		});

		test("throws error when repository not found", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" }],
				},
			});

			// Second getRef call (after listFolderContents) fails
			mockGetRef
				.mockResolvedValueOnce({ data: { object: { sha: mockRefSha } } })
				.mockRejectedValueOnce({ status: 404, message: "Not Found" });

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.deleteFolder("test-owner", "nonexistent", "content/guides")).rejects.toThrow(
				"Repository test-owner/nonexistent not found",
			);
		});

		test("throws original error for non-404 errors", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "blob1", path: "content/guides/intro.mdx" }],
				},
			});

			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockResolvedValueOnce({ data: { object: { sha: mockRefSha } } }).mockRejectedValueOnce(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.deleteFolder("test-owner", "test-repo", "content/guides")).rejects.toEqual(error);
		});
	});

	describe("moveFile", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockNewTreeSha = "new-tree-sha-abc";
		const mockNewCommitSha = "new-commit-sha-def";
		const mockFileSha = "file-sha-xyz";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: mockFileSha, path: "content/intro.mdx" },
						{ type: "blob", sha: "other-sha", path: "content/other.mdx" },
					],
				},
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("moves file to new folder", async () => {
			const github = createDocsiteGitHub(mockOctokit);
			await github.moveFile("test-owner", "test-repo", "content/intro.mdx", "content/guides");

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: [
					{ path: "content/guides/intro.mdx", mode: "100644", type: "blob", sha: mockFileSha },
					{ path: "content/intro.mdx", mode: "100644", type: "blob", sha: null },
				],
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Move content/intro.mdx to content/guides/intro.mdx",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("normalizes destination path", async () => {
			const github = createDocsiteGitHub(mockOctokit);
			await github.moveFile("test-owner", "test-repo", "content/intro.mdx", "content/guides/");

			expect(mockCreateTree).toHaveBeenCalledWith(
				expect.objectContaining({
					tree: expect.arrayContaining([
						expect.objectContaining({ path: "content/guides/intro.mdx", sha: mockFileSha }),
					]),
				}),
			);
		});

		test("throws error when file not found", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "other-sha", path: "content/other.mdx" }],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.moveFile("test-owner", "test-repo", "content/nonexistent.mdx", "content/guides"),
			).rejects.toThrow("File content/nonexistent.mdx not found");
		});

		test("throws error when repository not found", async () => {
			const error = { status: 404, message: "Not Found" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.moveFile("test-owner", "nonexistent", "content/intro.mdx", "content/guides"),
			).rejects.toThrow("Repository test-owner/nonexistent not found");
		});

		test("handles invalid file path", async () => {
			const github = createDocsiteGitHub(mockOctokit);

			// Empty string after split will result in undefined fileName
			await expect(github.moveFile("test-owner", "test-repo", "", "content/guides")).rejects.toThrow(
				"Invalid file path:",
			);
		});

		test("throws original error for non-404 errors", async () => {
			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockRejectedValue(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.moveFile("test-owner", "test-repo", "content/intro.mdx", "content/guides"),
			).rejects.toEqual(error);
		});
	});

	describe("renameFolder", () => {
		const mockRefSha = "ref-sha-123";
		const mockTreeSha = "tree-sha-789";
		const mockNewTreeSha = "new-tree-sha-abc";
		const mockNewCommitSha = "new-commit-sha-def";

		beforeEach(() => {
			mockGetRef.mockResolvedValue({
				data: { object: { sha: mockRefSha } },
			});
			mockGetCommit.mockResolvedValue({
				data: { tree: { sha: mockTreeSha } },
			});
			mockCreateTree.mockResolvedValue({
				data: { sha: mockNewTreeSha },
			});
			mockCreateCommit.mockResolvedValue({
				data: { sha: mockNewCommitSha },
			});
			mockUpdateRef.mockResolvedValue({});
		});

		test("renames folder and moves all files", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "sha1", path: "content/guides/intro.mdx" },
						{ type: "blob", sha: "sha2", path: "content/guides/advanced.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.renameFolder("test-owner", "test-repo", "content/guides", "tutorials");

			expect(mockCreateTree).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				tree: expect.arrayContaining([
					{ path: "content/tutorials/intro.mdx", mode: "100644", type: "blob", sha: "sha1" },
					{ path: "content/guides/intro.mdx", mode: "100644", type: "blob", sha: null },
					{ path: "content/tutorials/advanced.mdx", mode: "100644", type: "blob", sha: "sha2" },
					{ path: "content/guides/advanced.mdx", mode: "100644", type: "blob", sha: null },
				]),
				base_tree: mockTreeSha,
			});

			expect(mockCreateCommit).toHaveBeenCalledWith({
				owner: "test-owner",
				repo: "test-repo",
				message: "Rename folder content/guides to content/tutorials",
				tree: mockNewTreeSha,
				parents: [mockRefSha],
			});
		});

		test("preserves file SHAs during rename", async () => {
			const fileSha1 = "unique-sha-1";
			const fileSha2 = "unique-sha-2";

			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: fileSha1, path: "content/old/file1.mdx" },
						{ type: "blob", sha: fileSha2, path: "content/old/file2.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.renameFolder("test-owner", "test-repo", "content/old", "new");

			const createTreeCall = mockCreateTree.mock.calls[0][0];
			const addEntries = createTreeCall.tree.filter((entry: { sha: string | null }) => entry.sha !== null);

			expect(addEntries).toEqual(
				expect.arrayContaining([
					expect.objectContaining({ path: "content/new/file1.mdx", sha: fileSha1 }),
					expect.objectContaining({ path: "content/new/file2.mdx", sha: fileSha2 }),
				]),
			);
		});

		test("throws error when folder is empty", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "sha1", path: "content/other/file.mdx" }],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.renameFolder("test-owner", "test-repo", "content/guides", "tutorials")).rejects.toThrow(
				"Folder content/guides is empty or doesn't exist",
			);
		});

		test("throws error when repository not found", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "sha1", path: "content/guides/intro.mdx" }],
				},
			});

			mockGetRef
				.mockResolvedValueOnce({ data: { object: { sha: mockRefSha } } })
				.mockRejectedValueOnce({ status: 404, message: "Not Found" });

			const github = createDocsiteGitHub(mockOctokit);

			await expect(
				github.renameFolder("test-owner", "nonexistent", "content/guides", "tutorials"),
			).rejects.toThrow("Repository test-owner/nonexistent not found");
		});

		test("handles nested folder structure", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [
						{ type: "blob", sha: "sha1", path: "content/guides/intro.mdx" },
						{ type: "blob", sha: "sha2", path: "content/guides/nested/deep.mdx" },
					],
				},
			});

			const github = createDocsiteGitHub(mockOctokit);
			await github.renameFolder("test-owner", "test-repo", "content/guides", "tutorials");

			expect(mockCreateTree).toHaveBeenCalledWith(
				expect.objectContaining({
					tree: expect.arrayContaining([
						expect.objectContaining({ path: "content/tutorials/intro.mdx" }),
						expect.objectContaining({ path: "content/tutorials/nested/deep.mdx" }),
					]),
				}),
			);
		});

		test("throws original error for non-404 errors", async () => {
			mockGetTree.mockResolvedValue({
				data: {
					tree: [{ type: "blob", sha: "sha1", path: "content/guides/intro.mdx" }],
				},
			});

			const error = { status: 500, message: "Internal Server Error" };
			mockGetRef.mockResolvedValueOnce({ data: { object: { sha: mockRefSha } } }).mockRejectedValueOnce(error);

			const github = createDocsiteGitHub(mockOctokit);

			await expect(github.renameFolder("test-owner", "test-repo", "content/guides", "tutorials")).rejects.toEqual(
				error,
			);
		});
	});
});
